'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var nacl = require('tweetnacl');
var buffer = require('buffer');
var BN = require('bn.js');
var bs58 = require('bs58');
var cryptoHash = require('crypto-hash');
var BufferLayout = require('buffer-layout');
var assert = require('assert');
var url = require('url');
var fetch = require('node-fetch');
var jayson = require('jayson/lib/client/browser');
var superstruct = require('superstruct');
var rpcWebsockets = require('rpc-websockets');
var http = require('http');
var https = require('https');
var secp256k1 = require('secp256k1');
var jsSha3 = require('js-sha3');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var _defineProperty__default = /*#__PURE__*/_interopDefaultLegacy(_defineProperty);
var nacl__default = /*#__PURE__*/_interopDefaultLegacy(nacl);
var BN__default = /*#__PURE__*/_interopDefaultLegacy(BN);
var bs58__default = /*#__PURE__*/_interopDefaultLegacy(bs58);
var assert__default = /*#__PURE__*/_interopDefaultLegacy(assert);
var fetch__default = /*#__PURE__*/_interopDefaultLegacy(fetch);
var jayson__default = /*#__PURE__*/_interopDefaultLegacy(jayson);
var http__default = /*#__PURE__*/_interopDefaultLegacy(http);
var https__default = /*#__PURE__*/_interopDefaultLegacy(https);
var secp256k1__default = /*#__PURE__*/_interopDefaultLegacy(secp256k1);

//      
const toBuffer = arr => {
  if (arr instanceof buffer.Buffer) {
    return arr;
  } else if (arr instanceof Uint8Array) {
    return buffer.Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);
  } else {
    return buffer.Buffer.from(arr);
  }
};

let naclLowLevel = nacl__default['default'].lowlevel; // This type exists to workaround an esdoc parse error

/**
 * Maximum length of derived pubkey seed
 */

const MAX_SEED_LENGTH = 32;
/**
 * A public key
 */

class PublicKey {
  /**
   * Create a new PublicKey object
   */
  constructor(value) {
    _defineProperty__default['default'](this, "_bn", void 0);

    if (typeof value === 'string') {
      // assume base 58 encoding by default
      const decoded = bs58__default['default'].decode(value);

      if (decoded.length != 32) {
        throw new Error(`Invalid public key input`);
      }

      this._bn = new BN__default['default'](decoded);
    } else {
      this._bn = new BN__default['default'](value);
    }

    if (this._bn.byteLength() > 32) {
      throw new Error(`Invalid public key input`);
    }
  }
  /**
   * Checks if two publicKeys are equal
   */


  equals(publicKey) {
    return this._bn.eq(publicKey._bn);
  }
  /**
   * Return the base-58 representation of the public key
   */


  toBase58() {
    return bs58__default['default'].encode(this.toBuffer());
  }
  /**
   * Return the Buffer representation of the public key
   */


  toBuffer() {
    const b = this._bn.toArrayLike(buffer.Buffer);

    if (b.length === 32) {
      return b;
    }

    const zeroPad = buffer.Buffer.alloc(32);
    b.copy(zeroPad, 32 - b.length);
    return zeroPad;
  }
  /**
   * Returns a string representation of the public key
   */


  toString() {
    return this.toBase58();
  }
  /**
   * Derive a public key from another key, a seed, and a program ID.
   */


  static async createWithSeed(fromPublicKey, seed, programId) {
    const buffer$1 = buffer.Buffer.concat([fromPublicKey.toBuffer(), buffer.Buffer.from(seed), programId.toBuffer()]);
    const hash = await cryptoHash.sha256(new Uint8Array(buffer$1));
    return new PublicKey(buffer.Buffer.from(hash, 'hex'));
  }
  /**
   * Derive a program address from seeds and a program ID.
   */


  static async createProgramAddress(seeds, programId) {
    let buffer$1 = buffer.Buffer.alloc(0);
    seeds.forEach(function (seed) {
      if (seed.length > MAX_SEED_LENGTH) {
        throw new Error(`Max seed length exceeded`);
      }

      buffer$1 = buffer.Buffer.concat([buffer$1, buffer.Buffer.from(seed)]);
    });
    buffer$1 = buffer.Buffer.concat([buffer$1, programId.toBuffer(), buffer.Buffer.from('ProgramDerivedAddress')]);
    let hash = await cryptoHash.sha256(new Uint8Array(buffer$1));
    let publicKeyBytes = new BN__default['default'](hash, 16).toArray(null, 32);

    if (is_on_curve(publicKeyBytes)) {
      throw new Error(`Invalid seeds, address must fall off the curve`);
    }

    return new PublicKey(publicKeyBytes);
  }
  /**
   * Find a valid program address
   *
   * Valid program addresses must fall off the ed25519 curve.  This function
   * iterates a nonce until it finds one that when combined with the seeds
   * results in a valid program address.
   */


  static async findProgramAddress(seeds, programId) {
    let nonce = 255;
    let address;

    while (nonce != 0) {
      try {
        const seedsWithNonce = seeds.concat(buffer.Buffer.from([nonce]));
        address = await this.createProgramAddress(seedsWithNonce, programId);
      } catch (err) {
        nonce--;
        continue;
      }

      return [address, nonce];
    }

    throw new Error(`Unable to find a viable program address nonce`);
  }

} // Check that a pubkey is on the curve.
// This function and its dependents were sourced from:
// https://github.com/dchest/tweetnacl-js/blob/f1ec050ceae0861f34280e62498b1d3ed9c350c6/nacl.js#L792

function is_on_curve(p) {
  var r = [naclLowLevel.gf(), naclLowLevel.gf(), naclLowLevel.gf(), naclLowLevel.gf()];
  var t = naclLowLevel.gf(),
      chk = naclLowLevel.gf(),
      num = naclLowLevel.gf(),
      den = naclLowLevel.gf(),
      den2 = naclLowLevel.gf(),
      den4 = naclLowLevel.gf(),
      den6 = naclLowLevel.gf();
  naclLowLevel.set25519(r[2], gf1);
  naclLowLevel.unpack25519(r[1], p);
  naclLowLevel.S(num, r[1]);
  naclLowLevel.M(den, num, naclLowLevel.D);
  naclLowLevel.Z(num, num, r[2]);
  naclLowLevel.A(den, r[2], den);
  naclLowLevel.S(den2, den);
  naclLowLevel.S(den4, den2);
  naclLowLevel.M(den6, den4, den2);
  naclLowLevel.M(t, den6, num);
  naclLowLevel.M(t, t, den);
  naclLowLevel.pow2523(t, t);
  naclLowLevel.M(t, t, num);
  naclLowLevel.M(t, t, den);
  naclLowLevel.M(t, t, den);
  naclLowLevel.M(r[0], t, den);
  naclLowLevel.S(chk, r[0]);
  naclLowLevel.M(chk, chk, den);
  if (neq25519(chk, num)) naclLowLevel.M(r[0], r[0], I);
  naclLowLevel.S(chk, r[0]);
  naclLowLevel.M(chk, chk, den);
  if (neq25519(chk, num)) return 0;
  return 1;
}

let gf1 = naclLowLevel.gf([1]);
let I = naclLowLevel.gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);

function neq25519(a, b) {
  var c = new Uint8Array(32),
      d = new Uint8Array(32);
  naclLowLevel.pack25519(c, a);
  naclLowLevel.pack25519(d, b);
  return naclLowLevel.crypto_verify_32(c, 0, d, 0);
}

/**
 * An account key pair (public and secret keys).
 */

class Account {
  /**
   * Create a new Account object
   *
   * If the secretKey parameter is not provided a new key pair is randomly
   * created for the account
   *
   * @param secretKey Secret key for the account
   */
  constructor(secretKey) {
    _defineProperty__default['default'](this, "_keypair", void 0);

    if (secretKey) {
      this._keypair = nacl__default['default'].sign.keyPair.fromSecretKey(toBuffer(secretKey));
    } else {
      this._keypair = nacl__default['default'].sign.keyPair();
    }
  }
  /**
   * The public key for this account
   */


  get publicKey() {
    return new PublicKey(this._keypair.publicKey);
  }
  /**
   * The **unencrypted** secret key for this account
   */


  get secretKey() {
    return this._keypair.secretKey;
  }

}

//      
const BPF_LOADER_DEPRECATED_PROGRAM_ID = new PublicKey('BPFLoader1111111111111111111111111111111111');

//      
/**
 * Layout for a public key
 */

const publicKey = (property = 'publicKey') => {
  return BufferLayout.blob(32, property);
};
/**
 * Layout for a Rust String type
 */

const rustString = (property = 'string') => {
  const rsl = BufferLayout.struct([BufferLayout.u32('length'), BufferLayout.u32('lengthPadding'), BufferLayout.blob(BufferLayout.offset(BufferLayout.u32(), -8), 'chars')], property);

  const _decode = rsl.decode.bind(rsl);

  const _encode = rsl.encode.bind(rsl);

  rsl.decode = (buffer, offset) => {
    const data = _decode(buffer, offset);

    return data.chars.toString('utf8');
  };

  rsl.encode = (str, buffer$1, offset) => {
    const data = {
      chars: buffer.Buffer.from(str, 'utf8')
    };
    return _encode(data, buffer$1, offset);
  };

  rsl.alloc = str => {
    return BufferLayout.u32().span + BufferLayout.u32().span + buffer.Buffer.from(str, 'utf8').length;
  };

  return rsl;
};
/**
 * Layout for an Authorized object
 */

const authorized = (property = 'authorized') => {
  return BufferLayout.struct([publicKey('staker'), publicKey('withdrawer')], property);
};
/**
 * Layout for a Lockup object
 */

const lockup = (property = 'lockup') => {
  return BufferLayout.struct([BufferLayout.ns64('unixTimestamp'), BufferLayout.ns64('epoch'), publicKey('custodian')], property);
};
function getAlloc(type, fields) {
  let alloc = 0;
  type.layout.fields.forEach(item => {
    if (item.span >= 0) {
      alloc += item.span;
    } else if (typeof item.alloc === 'function') {
      alloc += item.alloc(fields[item.property]);
    }
  });
  return alloc;
}

//      
function decodeLength(bytes) {
  let len = 0;
  let size = 0;

  for (;;) {
    let elem = bytes.shift();
    len |= (elem & 0x7f) << size * 7;
    size += 1;

    if ((elem & 0x80) === 0) {
      break;
    }
  }

  return len;
}
function encodeLength(bytes, len) {
  let rem_len = len;

  for (;;) {
    let elem = rem_len & 0x7f;
    rem_len >>= 7;

    if (rem_len == 0) {
      bytes.push(elem);
      break;
    } else {
      elem |= 0x80;
      bytes.push(elem);
    }
  }
}

/**
 * The message header, identifying signed and read-only account
 *
 * @typedef {Object} MessageHeader
 * @property {number} numRequiredSignatures The number of signatures required for this message to be considered valid. The
 * signatures must match the first `numRequiredSignatures` of `accountKeys`.
 * @property {number} numReadonlySignedAccounts: The last `numReadonlySignedAccounts` of the signed keys are read-only accounts
 * @property {number} numReadonlyUnsignedAccounts The last `numReadonlySignedAccounts` of the unsigned keys are read-only accounts
 */

/**
 * An instruction to execute by a program
 *
 * @typedef {Object} CompiledInstruction
 * @property {number} programIdIndex Index into the transaction keys array indicating the program account that executes this instruction
 * @property {number[]} accounts Ordered indices into the transaction keys array indicating which accounts to pass to the program
 * @property {string} data The program input data encoded as base 58
 */

/**
 * Message constructor arguments
 *
 * @typedef {Object} MessageArgs
 * @property {MessageHeader} header The message header, identifying signed and read-only `accountKeys`
 * @property {string[]} accounts All the account keys used by this transaction
 * @property {Blockhash} recentBlockhash The hash of a recent ledger block
 * @property {CompiledInstruction[]} instructions Instructions that will be executed in sequence and committed in one atomic transaction if all succeed.
 */

const PUBKEY_LENGTH = 32;
/**
 * List of instructions to be processed atomically
 */

class Message {
  constructor(args) {
    _defineProperty__default['default'](this, "header", void 0);

    _defineProperty__default['default'](this, "accountKeys", void 0);

    _defineProperty__default['default'](this, "recentBlockhash", void 0);

    _defineProperty__default['default'](this, "instructions", void 0);

    this.header = args.header;
    this.accountKeys = args.accountKeys.map(account => new PublicKey(account));
    this.recentBlockhash = args.recentBlockhash;
    this.instructions = args.instructions;
  }

  isAccountWritable(index) {
    return index < this.header.numRequiredSignatures - this.header.numReadonlySignedAccounts || index >= this.header.numRequiredSignatures && index < this.accountKeys.length - this.header.numReadonlyUnsignedAccounts;
  }

  serialize() {
    const numKeys = this.accountKeys.length;
    let keyCount = [];
    encodeLength(keyCount, numKeys);
    const instructions = this.instructions.map(instruction => {
      const {
        accounts,
        programIdIndex
      } = instruction;
      const data = bs58__default['default'].decode(instruction.data);
      let keyIndicesCount = [];
      encodeLength(keyIndicesCount, accounts.length);
      let dataCount = [];
      encodeLength(dataCount, data.length);
      return {
        programIdIndex,
        keyIndicesCount: buffer.Buffer.from(keyIndicesCount),
        keyIndices: buffer.Buffer.from(accounts),
        dataLength: buffer.Buffer.from(dataCount),
        data
      };
    });
    let instructionCount = [];
    encodeLength(instructionCount, instructions.length);
    let instructionBuffer = buffer.Buffer.alloc(PACKET_DATA_SIZE);
    buffer.Buffer.from(instructionCount).copy(instructionBuffer);
    let instructionBufferLength = instructionCount.length;
    instructions.forEach(instruction => {
      const instructionLayout = BufferLayout.struct([BufferLayout.u8('programIdIndex'), BufferLayout.blob(instruction.keyIndicesCount.length, 'keyIndicesCount'), BufferLayout.seq(BufferLayout.u8('keyIndex'), instruction.keyIndices.length, 'keyIndices'), BufferLayout.blob(instruction.dataLength.length, 'dataLength'), BufferLayout.seq(BufferLayout.u8('userdatum'), instruction.data.length, 'data')]);
      const length = instructionLayout.encode(instruction, instructionBuffer, instructionBufferLength);
      instructionBufferLength += length;
    });
    instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);
    const signDataLayout = BufferLayout.struct([BufferLayout.blob(1, 'numRequiredSignatures'), BufferLayout.blob(1, 'numReadonlySignedAccounts'), BufferLayout.blob(1, 'numReadonlyUnsignedAccounts'), BufferLayout.blob(keyCount.length, 'keyCount'), BufferLayout.seq(publicKey('key'), numKeys, 'keys'), publicKey('recentBlockhash')]);
    const transaction = {
      numRequiredSignatures: buffer.Buffer.from([this.header.numRequiredSignatures]),
      numReadonlySignedAccounts: buffer.Buffer.from([this.header.numReadonlySignedAccounts]),
      numReadonlyUnsignedAccounts: buffer.Buffer.from([this.header.numReadonlyUnsignedAccounts]),
      keyCount: buffer.Buffer.from(keyCount),
      keys: this.accountKeys.map(key => key.toBuffer()),
      recentBlockhash: bs58__default['default'].decode(this.recentBlockhash)
    };
    let signData = buffer.Buffer.alloc(2048);
    const length = signDataLayout.encode(transaction, signData);
    instructionBuffer.copy(signData, length);
    return signData.slice(0, length + instructionBuffer.length);
  }
  /**
   * Decode a compiled message into a Message object.
   */


  static from(buffer$1) {
    // Slice up wire data
    let byteArray = [...buffer$1];
    const numRequiredSignatures = byteArray.shift();
    const numReadonlySignedAccounts = byteArray.shift();
    const numReadonlyUnsignedAccounts = byteArray.shift();
    const accountCount = decodeLength(byteArray);
    let accountKeys = [];

    for (let i = 0; i < accountCount; i++) {
      const account = byteArray.slice(0, PUBKEY_LENGTH);
      byteArray = byteArray.slice(PUBKEY_LENGTH);
      accountKeys.push(bs58__default['default'].encode(buffer.Buffer.from(account)));
    }

    const recentBlockhash = byteArray.slice(0, PUBKEY_LENGTH);
    byteArray = byteArray.slice(PUBKEY_LENGTH);
    const instructionCount = decodeLength(byteArray);
    let instructions = [];

    for (let i = 0; i < instructionCount; i++) {
      let instruction = {};
      instruction.programIdIndex = byteArray.shift();
      const accountCount = decodeLength(byteArray);
      instruction.accounts = byteArray.slice(0, accountCount);
      byteArray = byteArray.slice(accountCount);
      const dataLength = decodeLength(byteArray);
      const data = byteArray.slice(0, dataLength);
      instruction.data = bs58__default['default'].encode(buffer.Buffer.from(data));
      byteArray = byteArray.slice(dataLength);
      instructions.push(instruction);
    }

    const messageArgs = {
      header: {
        numRequiredSignatures,
        numReadonlySignedAccounts,
        numReadonlyUnsignedAccounts
      },
      recentBlockhash: bs58__default['default'].encode(buffer.Buffer.from(recentBlockhash)),
      accountKeys,
      instructions
    };
    return new Message(messageArgs);
  }

}

/**
 * @typedef {string} TransactionSignature
 */

/**
 * Default (empty) signature
 *
 * Signatures are 64 bytes in length
 */

const DEFAULT_SIGNATURE = buffer.Buffer.alloc(64).fill(0);
/**
 * Maximum over-the-wire size of a Transaction
 *
 * 1280 is IPv6 minimum MTU
 * 40 bytes is the size of the IPv6 header
 * 8 bytes is the size of the fragment header
 */

const PACKET_DATA_SIZE = 1280 - 40 - 8;
const SIGNATURE_LENGTH = 64;
/**
 * Account metadata used to define instructions
 *
 * @typedef {Object} AccountMeta
 * @property {PublicKey} pubkey An account's public key
 * @property {boolean} isSigner True if an instruction requires a transaction signature matching `pubkey`
 * @property {boolean} isWritable True if the `pubkey` can be loaded as a read-write account.
 */

/**
 * List of TransactionInstruction object fields that may be initialized at construction
 *
 * @typedef {Object} TransactionInstructionCtorFields
 * @property {?Array<PublicKey>} keys
 * @property {?PublicKey} programId
 * @property {?Buffer} data
 */

/**
 * Configuration object for Transaction.serialize()
 *
 * @typedef {Object} SerializeConfig
 * @property {boolean|undefined} requireAllSignatures Require all transaction signatures be present (default: true)
 * @property {boolean|undefined} verifySignatures Verify provided signatures (default: true)
 */

/**
 * Transaction Instruction class
 */

class TransactionInstruction {
  /**
   * Public keys to include in this transaction
   * Boolean represents whether this pubkey needs to sign the transaction
   */

  /**
   * Program Id to execute
   */

  /**
   * Program input
   */
  constructor(opts) {
    _defineProperty__default['default'](this, "keys", []);

    _defineProperty__default['default'](this, "programId", void 0);

    _defineProperty__default['default'](this, "data", buffer.Buffer.alloc(0));

    opts && Object.assign(this, opts);
  }

}
/**
 * @private
 */

/**
 * List of Transaction object fields that may be initialized at construction
 *
 * @typedef {Object} TransactionCtorFields
 * @property {?Blockhash} recentBlockhash A recent blockhash
 * @property {?PublicKey} feePayer The transaction fee payer
 * @property {?Array<SignaturePubkeyPair>} signatures One or more signatures
 *
 */

/**
 * NonceInformation to be used to build a Transaction.
 *
 * @typedef {Object} NonceInformation
 * @property {Blockhash} nonce The current Nonce blockhash
 * @property {TransactionInstruction} nonceInstruction AdvanceNonceAccount Instruction
 */

/**
 * Transaction class
 */

class Transaction {
  /**
   * Signatures for the transaction.  Typically created by invoking the
   * `sign()` method
   */

  /**
   * The first (payer) Transaction signature
   */
  get signature() {
    if (this.signatures.length > 0) {
      return this.signatures[0].signature;
    }

    return null;
  }
  /**
   * The transaction fee payer
   */


  /**
   * Construct an empty Transaction
   */
  constructor(opts) {
    _defineProperty__default['default'](this, "signatures", []);

    _defineProperty__default['default'](this, "feePayer", void 0);

    _defineProperty__default['default'](this, "instructions", []);

    _defineProperty__default['default'](this, "recentBlockhash", void 0);

    _defineProperty__default['default'](this, "nonceInfo", void 0);

    opts && Object.assign(this, opts);
  }
  /**
   * Add one or more instructions to this Transaction
   */


  add(...items) {
    if (items.length === 0) {
      throw new Error('No instructions');
    }

    items.forEach(item => {
      if ('instructions' in item) {
        this.instructions = this.instructions.concat(item.instructions);
      } else if ('data' in item && 'programId' in item && 'keys' in item) {
        this.instructions.push(item);
      } else {
        this.instructions.push(new TransactionInstruction(item));
      }
    });
    return this;
  }
  /**
   * Compile transaction data
   */


  compileMessage() {
    const {
      nonceInfo
    } = this;

    if (nonceInfo && this.instructions[0] != nonceInfo.nonceInstruction) {
      this.recentBlockhash = nonceInfo.nonce;
      this.instructions.unshift(nonceInfo.nonceInstruction);
    }

    const {
      recentBlockhash
    } = this;

    if (!recentBlockhash) {
      throw new Error('Transaction recentBlockhash required');
    }

    if (this.instructions.length < 1) {
      throw new Error('No instructions provided');
    }

    let feePayer;

    if (this.feePayer) {
      feePayer = this.feePayer;
    } else if (this.signatures.length > 0 && this.signatures[0].publicKey) {
      // Use implicit fee payer
      feePayer = this.signatures[0].publicKey;
    } else {
      throw new Error('Transaction fee payer required');
    }

    const programIds = [];
    const accountMetas = [];
    this.instructions.forEach(instruction => {
      instruction.keys.forEach(accountMeta => {
        accountMetas.push({ ...accountMeta
        });
      });
      const programId = instruction.programId.toString();

      if (!programIds.includes(programId)) {
        programIds.push(programId);
      }
    }); // Append programID account metas

    programIds.forEach(programId => {
      accountMetas.push({
        pubkey: new PublicKey(programId),
        isSigner: false,
        isWritable: false
      });
    }); // Sort. Prioritizing first by signer, then by writable

    accountMetas.sort(function (x, y) {
      const checkSigner = x.isSigner === y.isSigner ? 0 : x.isSigner ? -1 : 1;
      const checkWritable = x.isWritable === y.isWritable ? 0 : x.isWritable ? -1 : 1;
      return checkSigner || checkWritable;
    }); // Cull duplicate account metas

    const uniqueMetas = [];
    accountMetas.forEach(accountMeta => {
      const pubkeyString = accountMeta.pubkey.toString();
      const uniqueIndex = uniqueMetas.findIndex(x => {
        return x.pubkey.toString() === pubkeyString;
      });

      if (uniqueIndex > -1) {
        uniqueMetas[uniqueIndex].isWritable = uniqueMetas[uniqueIndex].isWritable || accountMeta.isWritable;
      } else {
        uniqueMetas.push(accountMeta);
      }
    }); // Move fee payer to the front

    const feePayerIndex = uniqueMetas.findIndex(x => {
      return x.pubkey.equals(feePayer);
    });

    if (feePayerIndex > -1) {
      const [payerMeta] = uniqueMetas.splice(feePayerIndex, 1);
      payerMeta.isSigner = true;
      payerMeta.isWritable = true;
      uniqueMetas.unshift(payerMeta);
    } else {
      uniqueMetas.unshift({
        pubkey: feePayer,
        isSigner: true,
        isWritable: true
      });
    } // Disallow unknown signers


    for (const signature of this.signatures) {
      const uniqueIndex = uniqueMetas.findIndex(x => {
        return x.pubkey.equals(signature.publicKey);
      });

      if (uniqueIndex > -1) {
        if (!uniqueMetas[uniqueIndex].isSigner) {
          uniqueMetas[uniqueIndex].isSigner = true;
          console.warn('Transaction references a signature that is unnecessary, ' + 'only the fee payer and instruction signer accounts should sign a transaction. ' + 'This behavior is deprecated and will throw an error in the next major version release.');
        }
      } else {
        throw new Error(`unknown signer: ${signature.publicKey.toString()}`);
      }
    }

    let numRequiredSignatures = 0;
    let numReadonlySignedAccounts = 0;
    let numReadonlyUnsignedAccounts = 0; // Split out signing from non-signing keys and count header values

    const signedKeys = [];
    const unsignedKeys = [];
    uniqueMetas.forEach(({
      pubkey,
      isSigner,
      isWritable
    }) => {
      if (isSigner) {
        signedKeys.push(pubkey.toString());
        numRequiredSignatures += 1;

        if (!isWritable) {
          numReadonlySignedAccounts += 1;
        }
      } else {
        unsignedKeys.push(pubkey.toString());

        if (!isWritable) {
          numReadonlyUnsignedAccounts += 1;
        }
      }
    });
    const accountKeys = signedKeys.concat(unsignedKeys);
    const instructions = this.instructions.map(instruction => {
      const {
        data,
        programId
      } = instruction;
      return {
        programIdIndex: accountKeys.indexOf(programId.toString()),
        accounts: instruction.keys.map(meta => accountKeys.indexOf(meta.pubkey.toString())),
        data: bs58__default['default'].encode(data)
      };
    });
    instructions.forEach(instruction => {
      assert__default['default'](instruction.programIdIndex >= 0);
      instruction.accounts.forEach(keyIndex => assert__default['default'](keyIndex >= 0));
    });
    return new Message({
      header: {
        numRequiredSignatures,
        numReadonlySignedAccounts,
        numReadonlyUnsignedAccounts
      },
      accountKeys,
      recentBlockhash,
      instructions
    });
  }
  /**
   * @private
   */


  _compile() {
    const message = this.compileMessage();
    const signedKeys = message.accountKeys.slice(0, message.header.numRequiredSignatures);

    if (this.signatures.length === signedKeys.length) {
      const valid = this.signatures.every((pair, index) => {
        return signedKeys[index].equals(pair.publicKey);
      });
      if (valid) return message;
    }

    this.signatures = signedKeys.map(publicKey => ({
      signature: null,
      publicKey
    }));
    return message;
  }
  /**
   * Get a buffer of the Transaction data that need to be covered by signatures
   */


  serializeMessage() {
    return this._compile().serialize();
  }
  /**
   * Specify the public keys which will be used to sign the Transaction.
   * The first signer will be used as the transaction fee payer account.
   *
   * Signatures can be added with either `partialSign` or `addSignature`
   *
   * @deprecated Deprecated since v0.84.0. Only the fee payer needs to be
   * specified and it can be set in the Transaction constructor or with the
   * `feePayer` property.
   */


  setSigners(...signers) {
    if (signers.length === 0) {
      throw new Error('No signers');
    }

    const seen = new Set();
    this.signatures = signers.filter(publicKey => {
      const key = publicKey.toString();

      if (seen.has(key)) {
        return false;
      } else {
        seen.add(key);
        return true;
      }
    }).map(publicKey => ({
      signature: null,
      publicKey
    }));
  }
  /**
   * Sign the Transaction with the specified accounts. Multiple signatures may
   * be applied to a Transaction. The first signature is considered "primary"
   * and is used identify and confirm transactions.
   *
   * If the Transaction `feePayer` is not set, the first signer will be used
   * as the transaction fee payer account.
   *
   * Transaction fields should not be modified after the first call to `sign`,
   * as doing so may invalidate the signature and cause the Transaction to be
   * rejected.
   *
   * The Transaction must be assigned a valid `recentBlockhash` before invoking this method
   */


  sign(...signers) {
    if (signers.length === 0) {
      throw new Error('No signers');
    } // Dedupe signers


    const seen = new Set();
    const uniqueSigners = [];

    for (const signer of signers) {
      const key = signer.publicKey.toString();

      if (seen.has(key)) {
        continue;
      } else {
        seen.add(key);
        uniqueSigners.push(signer);
      }
    }

    this.signatures = uniqueSigners.map(signer => ({
      signature: null,
      publicKey: signer.publicKey
    }));

    const message = this._compile();

    this._partialSign(message, ...uniqueSigners);

    this._verifySignatures(message.serialize(), true);
  }
  /**
   * Partially sign a transaction with the specified accounts. All accounts must
   * correspond to either the fee payer or a signer account in the transaction
   * instructions.
   *
   * All the caveats from the `sign` method apply to `partialSign`
   */


  partialSign(...signers) {
    if (signers.length === 0) {
      throw new Error('No signers');
    } // Dedupe signers


    const seen = new Set();
    const uniqueSigners = [];

    for (const signer of signers) {
      const key = signer.publicKey.toString();

      if (seen.has(key)) {
        continue;
      } else {
        seen.add(key);
        uniqueSigners.push(signer);
      }
    }

    const message = this._compile();

    this._partialSign(message, ...uniqueSigners);
  }
  /**
   * @private
   */


  _partialSign(message, ...signers) {
    const signData = message.serialize();
    signers.forEach(signer => {
      const signature = nacl__default['default'].sign.detached(signData, signer.secretKey);

      this._addSignature(signer.publicKey, signature);
    });
  }
  /**
   * Add an externally created signature to a transaction. The public key
   * must correspond to either the fee payer or a signer account in the transaction
   * instructions.
   */


  addSignature(pubkey, signature) {
    this._compile(); // Ensure signatures array is populated


    this._addSignature(pubkey, signature);
  }
  /**
   * @private
   */


  _addSignature(pubkey, signature) {
    assert__default['default'](signature.length === 64);
    const index = this.signatures.findIndex(sigpair => pubkey.equals(sigpair.publicKey));

    if (index < 0) {
      throw new Error(`unknown signer: ${pubkey.toString()}`);
    }

    this.signatures[index].signature = buffer.Buffer.from(signature);
  }
  /**
   * Verify signatures of a complete, signed Transaction
   */


  verifySignatures() {
    return this._verifySignatures(this.serializeMessage(), true);
  }
  /**
   * @private
   */


  _verifySignatures(signData, requireAllSignatures) {
    for (const {
      signature,
      publicKey
    } of this.signatures) {
      if (signature === null) {
        if (requireAllSignatures) {
          return false;
        }
      } else {
        if (!nacl__default['default'].sign.detached.verify(signData, signature, publicKey.toBuffer())) {
          return false;
        }
      }
    }

    return true;
  }
  /**
   * Serialize the Transaction in the wire format.
   */


  serialize(config) {
    const {
      requireAllSignatures,
      verifySignatures
    } = Object.assign({
      requireAllSignatures: true,
      verifySignatures: true
    }, config);
    const signData = this.serializeMessage();

    if (verifySignatures && !this._verifySignatures(signData, requireAllSignatures)) {
      throw new Error('Signature verification failed');
    }

    return this._serialize(signData);
  }
  /**
   * @private
   */


  _serialize(signData) {
    const {
      signatures
    } = this;
    const signatureCount = [];
    encodeLength(signatureCount, signatures.length);
    const transactionLength = signatureCount.length + signatures.length * 64 + signData.length;
    const wireTransaction = buffer.Buffer.alloc(transactionLength);
    assert__default['default'](signatures.length < 256);
    buffer.Buffer.from(signatureCount).copy(wireTransaction, 0);
    signatures.forEach(({
      signature
    }, index) => {
      if (signature !== null) {
        assert__default['default'](signature.length === 64, `signature has invalid length`);
        buffer.Buffer.from(signature).copy(wireTransaction, signatureCount.length + index * 64);
      }
    });
    signData.copy(wireTransaction, signatureCount.length + signatures.length * 64);
    assert__default['default'](wireTransaction.length <= PACKET_DATA_SIZE, `Transaction too large: ${wireTransaction.length} > ${PACKET_DATA_SIZE}`);
    return wireTransaction;
  }
  /**
   * Deprecated method
   * @private
   */


  get keys() {
    assert__default['default'](this.instructions.length === 1);
    return this.instructions[0].keys.map(keyObj => keyObj.pubkey);
  }
  /**
   * Deprecated method
   * @private
   */


  get programId() {
    assert__default['default'](this.instructions.length === 1);
    return this.instructions[0].programId;
  }
  /**
   * Deprecated method
   * @private
   */


  get data() {
    assert__default['default'](this.instructions.length === 1);
    return this.instructions[0].data;
  }
  /**
   * Parse a wire transaction into a Transaction object.
   */


  static from(buffer$1) {
    // Slice up wire data
    let byteArray = [...buffer$1];
    const signatureCount = decodeLength(byteArray);
    let signatures = [];

    for (let i = 0; i < signatureCount; i++) {
      const signature = byteArray.slice(0, SIGNATURE_LENGTH);
      byteArray = byteArray.slice(SIGNATURE_LENGTH);
      signatures.push(bs58__default['default'].encode(buffer.Buffer.from(signature)));
    }

    return Transaction.populate(Message.from(byteArray), signatures);
  }
  /**
   * Populate Transaction object from message and signatures
   */


  static populate(message, signatures) {
    const transaction = new Transaction();
    transaction.recentBlockhash = message.recentBlockhash;

    if (message.header.numRequiredSignatures > 0) {
      transaction.feePayer = message.accountKeys[0];
    }

    signatures.forEach((signature, index) => {
      const sigPubkeyPair = {
        signature: signature == bs58__default['default'].encode(DEFAULT_SIGNATURE) ? null : bs58__default['default'].decode(signature),
        publicKey: message.accountKeys[index]
      };
      transaction.signatures.push(sigPubkeyPair);
    });
    message.instructions.forEach(instruction => {
      const keys = instruction.accounts.map(account => {
        const pubkey = message.accountKeys[account];
        return {
          pubkey,
          isSigner: transaction.signatures.some(keyObj => keyObj.publicKey.toString() === pubkey.toString()),
          isWritable: message.isAccountWritable(account)
        };
      });
      transaction.instructions.push(new TransactionInstruction({
        keys,
        programId: message.accountKeys[instruction.programIdIndex],
        data: bs58__default['default'].decode(instruction.data)
      }));
    });
    return transaction;
  }

}

//      
const SYSVAR_CLOCK_PUBKEY = new PublicKey('SysvarC1ock11111111111111111111111111111111');
const SYSVAR_RECENT_BLOCKHASHES_PUBKEY = new PublicKey('SysvarRecentB1ockHashes11111111111111111111');
const SYSVAR_RENT_PUBKEY = new PublicKey('SysvarRent111111111111111111111111111111111');
const SYSVAR_REWARDS_PUBKEY = new PublicKey('SysvarRewards111111111111111111111111111111');
const SYSVAR_STAKE_HISTORY_PUBKEY = new PublicKey('SysvarStakeHistory1111111111111111111111111');
const SYSVAR_INSTRUCTIONS_PUBKEY = new PublicKey('Sysvar1nstructions1111111111111111111111111');

const DESTROY_TIMEOUT_MS = 5000;
class AgentManager {
  static _newAgent(useHttps) {
    const options = {
      keepAlive: true,
      maxSockets: 25
    };

    if (useHttps) {
      return new https__default['default'].Agent(options);
    } else {
      return new http__default['default'].Agent(options);
    }
  }

  constructor(useHttps) {
    _defineProperty__default['default'](this, "_agent", void 0);

    _defineProperty__default['default'](this, "_activeRequests", 0);

    _defineProperty__default['default'](this, "_destroyTimeout", null);

    _defineProperty__default['default'](this, "_useHttps", void 0);

    this._useHttps = useHttps === true;
    this._agent = AgentManager._newAgent(this._useHttps);
  }

  requestStart() {
    this._activeRequests++;
    clearTimeout(this._destroyTimeout);
    this._destroyTimeout = null;
    return this._agent;
  }

  requestEnd() {
    this._activeRequests--;

    if (this._activeRequests === 0 && this._destroyTimeout === null) {
      this._destroyTimeout = setTimeout(() => {
        this._agent.destroy();

        this._agent = AgentManager._newAgent(this._useHttps);
      }, DESTROY_TIMEOUT_MS);
    }
  }

}

//      
/**
 * https://github.com/solana-labs/solana/blob/90bedd7e067b5b8f3ddbb45da00a4e9cabb22c62/sdk/src/fee_calculator.rs#L7-L11
 *
 * @private
 */

const FeeCalculatorLayout = BufferLayout.nu64('lamportsPerSignature');
/**
 * @typedef {Object} FeeCalculator
 * @property {number} lamportsPerSignature lamports Cost in lamports to validate a signature
 */

/**
 * See https://github.com/solana-labs/solana/blob/0ea2843ec9cdc517572b8e62c959f41b55cf4453/sdk/src/nonce_state.rs#L29-L32
 *
 * @private
 */

const NonceAccountLayout = BufferLayout.struct([BufferLayout.u32('version'), BufferLayout.u32('state'), publicKey('authorizedPubkey'), publicKey('nonce'), BufferLayout.struct([FeeCalculatorLayout], 'feeCalculator')]);
const NONCE_ACCOUNT_LENGTH = NonceAccountLayout.span;
/**
 * NonceAccount class
 */

class NonceAccount {
  constructor() {
    _defineProperty__default['default'](this, "authorizedPubkey", void 0);

    _defineProperty__default['default'](this, "nonce", void 0);

    _defineProperty__default['default'](this, "feeCalculator", void 0);
  }

  /**
   * Deserialize NonceAccount from the account data.
   *
   * @param buffer account data
   * @return NonceAccount
   */
  static fromAccountData(buffer) {
    const nonceAccount = NonceAccountLayout.decode(toBuffer(buffer), 0);
    nonceAccount.authorizedPubkey = new PublicKey(nonceAccount.authorizedPubkey);
    nonceAccount.nonce = new PublicKey(nonceAccount.nonce).toString();
    return nonceAccount;
  }

}

//      
// TODO: These constants should be removed in favor of reading them out of a
// Syscall account

/**
 * @ignore
 */
const NUM_TICKS_PER_SECOND = 160;
/**
 * @ignore
 */

const DEFAULT_TICKS_PER_SLOT = 64;
/**
 * @ignore
 */

const NUM_SLOTS_PER_SECOND = NUM_TICKS_PER_SECOND / DEFAULT_TICKS_PER_SLOT;
/**
 * @ignore
 */

const MS_PER_SLOT = 1000 / NUM_SLOTS_PER_SECOND;

//      
// zzz
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

//      
function promiseTimeout(promise, timeoutMs) {
  let timeoutId;
  const timeoutPromise = new Promise(resolve => {
    timeoutId = setTimeout(() => resolve(null), timeoutMs);
  });
  return Promise.race([promise, timeoutPromise]).then(result => {
    clearTimeout(timeoutId);
    return result;
  });
}

const BLOCKHASH_CACHE_TIMEOUT_MS = 30 * 1000;
/**
 * Extra contextual information for RPC responses
 *
 * @typedef {Object} Context
 * @property {number} slot
 */

/**
 * Options for sending transactions
 *
 * @typedef {Object} SendOptions
 * @property {boolean | undefined} skipPreflight disable transaction verification step
 * @property {Commitment | undefined} preflightCommitment preflight commitment level
 */

/**
 * Options for confirming transactions
 *
 * @typedef {Object} ConfirmOptions
 * @property {boolean | undefined} skipPreflight disable transaction verification step
 * @property {Commitment | undefined} commitment desired commitment level
 * @property {Commitment | undefined} preflightCommitment preflight commitment level
 */

/**
 * Options for getConfirmedSignaturesForAddress2
 *
 * @typedef {Object} ConfirmedSignaturesForAddress2Options
 * @property {TransactionSignature | undefined} before start searching backwards from this transaction signature.
 *               If not provided the search starts from the highest max confirmed block.
 * @property {number | undefined} limit maximum transaction signatures to return (between 1 and 1,000, default: 1,000).
 *
 */

/**
 * RPC Response with extra contextual information
 *
 * @typedef {Object} RpcResponseAndContext
 * @property {Context} context
 * @property {T} value response
 */

/**
 * @private
 */

function jsonRpcResultAndContext(resultDescription) {
  return jsonRpcResult({
    context: superstruct.struct({
      slot: 'number'
    }),
    value: resultDescription
  });
}
/**
 * @private
 */


function jsonRpcResult(resultDescription) {
  const jsonRpcVersion = superstruct.struct.literal('2.0');
  return superstruct.struct.union([superstruct.struct({
    jsonrpc: jsonRpcVersion,
    id: 'string',
    error: 'any'
  }), superstruct.struct({
    jsonrpc: jsonRpcVersion,
    id: 'string',
    error: 'null?',
    result: resultDescription
  })]);
}
/**
 * @private
 */


function notificationResultAndContext(resultDescription) {
  return superstruct.struct({
    context: superstruct.struct({
      slot: 'number'
    }),
    value: resultDescription
  });
}
/**
 * The level of commitment desired when querying state
 * <pre>
 *   'max':    Query the most recent block which has been finalized by the cluster
 *   'recent': Query the most recent block which has reached 1 confirmation by the connected node
 *   'root':   Query the most recent block which has been rooted by the connected node
 *   'single': Query the most recent block which has reached 1 confirmation by the cluster
 *   'singleGossip': Query the most recent block which has reached 1 confirmation according to votes seen in gossip
 * </pre>
 *
 * @typedef {'max' | 'recent' | 'root' | 'single' | 'singleGossip'} Commitment
 */

/**
 * Filter for largest accounts query
 * <pre>
 *   'circulating':    Return the largest accounts that are part of the circulating supply
 *   'nonCirculating': Return the largest accounts that are not part of the circulating supply
 * </pre>
 *
 * @typedef {'circulating' | 'nonCirculating'} LargestAccountsFilter
 */

/**
 * Configuration object for changing `getLargestAccounts` query behavior
 *
 * @typedef {Object} GetLargestAccountsConfig
 * @property {Commitment|undefined} commitment The level of commitment desired
 * @property {LargestAccountsFilter|undefined} filter Filter largest accounts by whether they are part of the circulating supply
 */

/**
 * Configuration object for changing query behavior
 *
 * @typedef {Object} SignatureStatusConfig
 * @property {boolean} searchTransactionHistory enable searching status history, not needed for recent transactions
 */

/**
 * Information describing a cluster node
 *
 * @typedef {Object} ContactInfo
 * @property {string} pubkey Identity public key of the node
 * @property {string|null} gossip Gossip network address for the node
 * @property {string|null} tpu TPU network address for the node (null if not available)
 * @property {string|null} rpc JSON RPC network address for the node (null if not available)
 * @property {string|null} version Software version of the node (null if not available)
 */

/**
 * Information describing a vote account
 *
 * @typedef {Object} VoteAccountInfo
 * @property {string} votePubkey Public key of the vote account
 * @property {string} nodePubkey Identity public key of the node voting with this account
 * @property {number} activatedStake The stake, in lamports, delegated to this vote account and activated
 * @property {boolean} epochVoteAccount Whether the vote account is staked for this epoch
 * @property {Array<Array<number>>} epochCredits Recent epoch voting credit history for this voter
 * @property {number} commission A percentage (0-100) of rewards payout owed to the voter
 * @property {number} lastVote Most recent slot voted on by this vote account
 */

/**
 * A collection of cluster vote accounts
 *
 * @typedef {Object} VoteAccountStatus
 * @property {Array<VoteAccountInfo>} current Active vote accounts
 * @property {Array<VoteAccountInfo>} delinquent Inactive vote accounts
 */

/**
 * Network Inflation
 * (see https://docs.solana.com/implemented-proposals/ed_overview)
 *
 * @typedef {Object} InflationGovernor
 * @property {number} foundation
 * @property {number} foundation_term
 * @property {number} initial
 * @property {number} taper
 * @property {number} terminal
 */


const GetInflationGovernorResult = superstruct.struct({
  foundation: 'number',
  foundationTerm: 'number',
  initial: 'number',
  taper: 'number',
  terminal: 'number'
});
/**
 * Information about the current epoch
 *
 * @typedef {Object} EpochInfo
 * @property {number} epoch
 * @property {number} slotIndex
 * @property {number} slotsInEpoch
 * @property {number} absoluteSlot
 * @property {number} blockHeight
 * @property {number} transactionCount
 */

const GetEpochInfoResult = superstruct.struct({
  epoch: 'number',
  slotIndex: 'number',
  slotsInEpoch: 'number',
  absoluteSlot: 'number',
  blockHeight: 'number?',
  transactionCount: 'number?'
});
/**
 * Epoch schedule
 * (see https://docs.solana.com/terminology#epoch)
 *
 * @typedef {Object} EpochSchedule
 * @property {number} slotsPerEpoch The maximum number of slots in each epoch
 * @property {number} leaderScheduleSlotOffset The number of slots before beginning of an epoch to calculate a leader schedule for that epoch
 * @property {boolean} warmup Indicates whether epochs start short and grow
 * @property {number} firstNormalEpoch The first epoch with `slotsPerEpoch` slots
 * @property {number} firstNormalSlot The first slot of `firstNormalEpoch`
 */

const GetEpochScheduleResult = superstruct.struct({
  slotsPerEpoch: 'number',
  leaderScheduleSlotOffset: 'number',
  warmup: 'boolean',
  firstNormalEpoch: 'number',
  firstNormalSlot: 'number'
});
/**
 * Leader schedule
 * (see https://docs.solana.com/terminology#leader-schedule)
 *
 * @typedef {Object} LeaderSchedule
 */

const GetLeaderScheduleResult = superstruct.struct.record(['string', 'any' // validating struct.array(['number']) is extremely slow
]);
/**
 * Transaction error or null
 */

const TransactionErrorResult = superstruct.struct.union(['null', 'object']);
/**
 * Signature status for a transaction
 */

const SignatureStatusResult = superstruct.struct({
  err: TransactionErrorResult
});
/**
 * Version info for a node
 *
 * @typedef {Object} Version
 * @property {string} solana-core Version of solana-core
 */

const Version = superstruct.struct.pick({
  'solana-core': 'string',
  'feature-set': 'number?'
});
const SimulatedTransactionResponseValidator = jsonRpcResultAndContext(superstruct.struct.pick({
  err: superstruct.struct.union(['null', 'object', 'string']),
  logs: superstruct.struct.union(['null', superstruct.struct.array(['string'])])
}));
/**
 * Metadata for a parsed confirmed transaction on the ledger
 *
 * @typedef {Object} ParsedConfirmedTransactionMeta
 * @property {number} fee The fee charged for processing the transaction
 * @property {Array<ParsedInnerInstruction>} innerInstructions An array of cross program invoked parsed instructions
 * @property {Array<number>} preBalances The balances of the transaction accounts before processing
 * @property {Array<number>} postBalances The balances of the transaction accounts after processing
 * @property {Array<string>} logMessages An array of program log messages emitted during a transaction
 * @property {Array<TokenBalance>} preTokenBalances The token balances of the transaction accounts before processing
 * @property {Array<TokenBalance>} postTokenBalances The token balances of the transaction accounts after processing
 * @property {object|null} err The error result of transaction processing
 */

/**
 * Metadata for a confirmed transaction on the ledger
 *
 * @typedef {Object} ConfirmedTransactionMeta
 * @property {number} fee The fee charged for processing the transaction
 * @property {Array<CompiledInnerInstruction>} innerInstructions An array of cross program invoked instructions
 * @property {Array<number>} preBalances The balances of the transaction accounts before processing
 * @property {Array<number>} postBalances The balances of the transaction accounts after processing
 * @property {Array<string>} logMessages An array of program log messages emitted during a transaction
 * @property {Array<TokenBalance>} preTokenBalances The token balances of the transaction accounts before processing
 * @property {Array<TokenBalance>} postTokenBalances The token balances of the transaction accounts after processing
 * @property {object|null} err The error result of transaction processing
 */

/**
 * A confirmed transaction on the ledger
 *
 * @typedef {Object} ConfirmedTransaction
 * @property {number} slot The slot during which the transaction was processed
 * @property {Transaction} transaction The details of the transaction
 * @property {ConfirmedTransactionMeta|null} meta Metadata produced from the transaction
 * @property {number|null|undefined} blockTime The unix timestamp of when the transaction was processed
 */

/**
 * A partially decoded transaction instruction
 *
 * @typedef {Object} ParsedMessageAccount
 * @property {PublicKey} pubkey Public key of the account
 * @property {PublicKey} accounts Indicates if the account signed the transaction
 * @property {string} data Raw base-58 instruction data
 */

/**
 * A parsed transaction message account
 *
 * @typedef {Object} ParsedMessageAccount
 * @property {PublicKey} pubkey Public key of the account
 * @property {boolean} signer Indicates if the account signed the transaction
 * @property {boolean} writable Indicates if the account is writable for this transaction
 */

/**
 * A parsed transaction instruction
 *
 * @typedef {Object} ParsedInstruction
 * @property {string} program Name of the program for this instruction
 * @property {PublicKey} programId ID of the program for this instruction
 * @property {any} parsed Parsed instruction info
 */

/**
 * A parsed transaction message
 *
 * @typedef {Object} ParsedMessage
 * @property {Array<ParsedMessageAccount>} accountKeys Accounts used in the instructions
 * @property {Array<ParsedInstruction | PartiallyDecodedInstruction>} instructions The atomically executed instructions for the transaction
 * @property {string} recentBlockhash Recent blockhash
 */

/**
 * A parsed transaction
 *
 * @typedef {Object} ParsedTransaction
 * @property {Array<string>} signatures Signatures for the transaction
 * @property {ParsedMessage} message Message of the transaction
 */

/**
 * A parsed and confirmed transaction on the ledger
 *
 * @typedef {Object} ParsedConfirmedTransaction
 * @property {number} slot The slot during which the transaction was processed
 * @property {ParsedTransaction} transaction The details of the transaction
 * @property {ConfirmedTransactionMeta|null} meta Metadata produced from the transaction
 * @property {number|null|undefined} blockTime The unix timestamp of when the transaction was processed
 */

/**
 * A ConfirmedBlock on the ledger
 *
 * @typedef {Object} ConfirmedBlock
 * @property {Blockhash} blockhash Blockhash of this block
 * @property {Blockhash} previousBlockhash Blockhash of this block's parent
 * @property {number} parentSlot Slot index of this block's parent
 * @property {Array<object>} transactions Vector of transactions and status metas
 * @property {Array<object>} rewards Vector of block rewards
 */

/**
 * A performance sample
 *
 * @typedef {Object} PerfSample
 * @property {number} slot Slot number of sample
 * @property {number} numTransactions Number of transactions in a sample window
 * @property {number} numSlots Number of slots in a sample window
 * @property {number} samplePeriodSecs Sample window in seconds
 */

function createRpcRequest(url, useHttps) {
  let agentManager;

  {
    agentManager = new AgentManager(useHttps);
  }

  const server = jayson__default['default'](async (request, callback) => {
    const agent = agentManager ? agentManager.requestStart() : undefined;
    const options = {
      method: 'POST',
      body: request,
      agent,
      headers: {
        'Content-Type': 'application/json'
      }
    };

    try {
      let too_many_requests_retries = 5;
      let res = {};
      let waitTime = 500;

      for (;;) {
        res = await fetch__default['default'](url, options);

        if (res.status !== 429
        /* Too many requests */
        ) {
            break;
          }

        too_many_requests_retries -= 1;

        if (too_many_requests_retries === 0) {
          break;
        }

        console.log(`Server responded with ${res.status} ${res.statusText}.  Retrying after ${waitTime}ms delay...`);
        await sleep(waitTime);
        waitTime *= 2;
      }

      const text = await res.text();

      if (res.ok) {
        callback(null, text);
      } else {
        callback(new Error(`${res.status} ${res.statusText}: ${text}`));
      }
    } catch (err) {
      callback(err);
    } finally {
      agentManager && agentManager.requestEnd();
    }
  });
  return (method, args) => {
    return new Promise((resolve, reject) => {
      server.request(method, args, (err, response) => {
        if (err) {
          reject(err);
          return;
        }

        resolve(response);
      });
    });
  };
}
/**
 * Expected JSON RPC response for the "getInflationGovernor" message
 */


const GetInflationGovernorRpcResult = superstruct.struct({
  jsonrpc: superstruct.struct.literal('2.0'),
  id: 'string',
  error: 'any?',
  result: GetInflationGovernorResult
});
/**
 * Expected JSON RPC response for the "getEpochInfo" message
 */

const GetEpochInfoRpcResult = superstruct.struct({
  jsonrpc: superstruct.struct.literal('2.0'),
  id: 'string',
  error: 'any?',
  result: GetEpochInfoResult
});
/**
 * Expected JSON RPC response for the "getEpochSchedule" message
 */

const GetEpochScheduleRpcResult = superstruct.struct({
  jsonrpc: superstruct.struct.literal('2.0'),
  id: 'string',
  error: 'any?',
  result: GetEpochScheduleResult
});
/**
 * Expected JSON RPC response for the "getLeaderSchedule" message
 */

const GetLeaderScheduleRpcResult = jsonRpcResult(GetLeaderScheduleResult);
/**
 * Expected JSON RPC response for the "getBalance" message
 */

const GetBalanceAndContextRpcResult = jsonRpcResultAndContext('number?');
/**
 * Expected JSON RPC response for the "getBlockTime" message
 */

const GetBlockTimeRpcResult = superstruct.struct({
  jsonrpc: superstruct.struct.literal('2.0'),
  id: 'string',
  error: 'any?',
  result: superstruct.struct.union(['null', 'number', 'undefined'])
});
/**
 * Expected JSON RPC response for the "minimumLedgerSlot" and "getFirstAvailableBlock" messages
 */

const SlotRpcResult = superstruct.struct({
  jsonrpc: superstruct.struct.literal('2.0'),
  id: 'string',
  error: 'any?',
  result: 'number'
});
/**
 * Supply
 *
 * @typedef {Object} Supply
 * @property {number} total Total supply in lamports
 * @property {number} circulating Circulating supply in lamports
 * @property {number} nonCirculating Non-circulating supply in lamports
 * @property {Array<PublicKey>} nonCirculatingAccounts List of non-circulating account addresses
 */

/**
 * Expected JSON RPC response for the "getSupply" message
 */

const GetSupplyRpcResult = jsonRpcResultAndContext(superstruct.struct({
  total: 'number',
  circulating: 'number',
  nonCirculating: 'number',
  nonCirculatingAccounts: superstruct.struct.array(['string'])
}));
/**
 * Token amount object which returns a token amount in different formats
 * for various client use cases.
 *
 * @typedef {Object} TokenAmount
 * @property {string} amount Raw amount of tokens as string ignoring decimals
 * @property {number} decimals Number of decimals configured for token's mint
 * @property {number} uiAmount Token account as float, accounts for decimals
 */

/**
 * Expected JSON RPC structure for token amounts
 */

const TokenAmountResult = superstruct.struct.object({
  amount: 'string',
  uiAmount: 'number',
  decimals: 'number'
});
/**
 * Token address and balance.
 *
 * @typedef {Object} TokenAccountBalancePair
 * @property {PublicKey} address Address of the token account
 * @property {string} amount Raw amount of tokens as string ignoring decimals
 * @property {number} decimals Number of decimals configured for token's mint
 * @property {number} uiAmount Token account as float, accounts for decimals
 */

/**
 * Expected JSON RPC response for the "getTokenLargestAccounts" message
 */

const GetTokenLargestAccountsResult = jsonRpcResultAndContext(superstruct.struct.array([superstruct.struct.pick({
  address: 'string',
  amount: 'string',
  uiAmount: 'number',
  decimals: 'number'
})]));
/**
 * Expected JSON RPC response for the "getTokenAccountBalance" message
 */

const GetTokenAccountBalance = jsonRpcResultAndContext(TokenAmountResult);
/**
 * Expected JSON RPC response for the "getTokenSupply" message
 */

const GetTokenSupplyRpcResult = jsonRpcResultAndContext(TokenAmountResult);
/**
 * Expected JSON RPC response for the "getTokenAccountsByOwner" message
 */

const GetTokenAccountsByOwner = jsonRpcResultAndContext(superstruct.struct.array([superstruct.struct.object({
  pubkey: 'string',
  account: superstruct.struct.object({
    executable: 'boolean',
    owner: 'string',
    lamports: 'number',
    data: ['string', superstruct.struct.literal('base64')],
    rentEpoch: 'number?'
  })
})]));
/**
 * Expected JSON RPC response for the "getTokenAccountsByOwner" message with parsed data
 */

const GetParsedTokenAccountsByOwner = jsonRpcResultAndContext(superstruct.struct.array([superstruct.struct.object({
  pubkey: 'string',
  account: superstruct.struct.object({
    executable: 'boolean',
    owner: 'string',
    lamports: 'number',
    data: superstruct.struct.pick({
      program: 'string',
      parsed: 'any',
      space: 'number'
    }),
    rentEpoch: 'number?'
  })
})]));
/**
 * Pair of an account address and its balance
 *
 * @typedef {Object} AccountBalancePair
 * @property {PublicKey} address
 * @property {number} lamports
 */

/**
 * Expected JSON RPC response for the "getLargestAccounts" message
 */

const GetLargestAccountsRpcResult = jsonRpcResultAndContext(superstruct.struct.array([superstruct.struct({
  lamports: 'number',
  address: 'string'
})]));
/**
 * Expected JSON RPC response for the "getVersion" message
 */

const GetVersionRpcResult = superstruct.struct({
  jsonrpc: superstruct.struct.literal('2.0'),
  id: 'string',
  error: 'any?',
  result: Version
});
/**
 * @private
 */

const AccountInfoResult = superstruct.struct({
  executable: 'boolean',
  owner: 'string',
  lamports: 'number',
  data: 'any',
  rentEpoch: 'number?'
});
/**
 * @private
 */

const ParsedAccountInfoResult = superstruct.struct.object({
  executable: 'boolean',
  owner: 'string',
  lamports: 'number',
  data: superstruct.struct.union([['string', superstruct.struct.literal('base64')], superstruct.struct.pick({
    program: 'string',
    parsed: 'any',
    space: 'number'
  })]),
  rentEpoch: 'number?'
});
/**
 * @private
 */

const StakeActivationResult = superstruct.struct.object({
  state: superstruct.struct.union([superstruct.struct.literal('active'), superstruct.struct.literal('inactive'), superstruct.struct.literal('activating'), superstruct.struct.literal('deactivating')]),
  active: 'number',
  inactive: 'number'
});
/**
 * Expected JSON RPC response for the "getAccountInfo" message
 */

const GetAccountInfoAndContextRpcResult = jsonRpcResultAndContext(superstruct.struct.union(['null', AccountInfoResult]));
/**
 * Expected JSON RPC response for the "getAccountInfo" message with jsonParsed param
 */

const GetParsedAccountInfoResult = jsonRpcResultAndContext(superstruct.struct.union(['null', ParsedAccountInfoResult]));
/**
 * Expected JSON RPC response for the "getStakeActivation" message with jsonParsed param
 */

const GetStakeActivationResult = jsonRpcResult(StakeActivationResult);
/**
 * Expected JSON RPC response for the "getConfirmedSignaturesForAddress" message
 */

const GetConfirmedSignaturesForAddressRpcResult = jsonRpcResult(superstruct.struct.array(['string']));
/**
 * Expected JSON RPC response for the "getConfirmedSignaturesForAddress2" message
 */

const GetConfirmedSignaturesForAddress2RpcResult = jsonRpcResult(superstruct.struct.array([superstruct.struct.pick({
  signature: 'string',
  slot: 'number',
  err: TransactionErrorResult,
  memo: superstruct.struct.union(['null', 'string']),
  blockTime: superstruct.struct.union(['undefined', 'null', 'number'])
})]));
/***
 * Expected JSON RPC response for the "accountNotification" message
 */

const AccountNotificationResult = superstruct.struct({
  subscription: 'number',
  result: notificationResultAndContext(AccountInfoResult)
});
/**
 * @private
 */

const ProgramAccountInfoResult = superstruct.struct({
  pubkey: 'string',
  account: AccountInfoResult
});
/**
 * @private
 */

const ParsedProgramAccountInfoResult = superstruct.struct({
  pubkey: 'string',
  account: ParsedAccountInfoResult
});
/***
 * Expected JSON RPC response for the "programNotification" message
 */

const ProgramAccountNotificationResult = superstruct.struct({
  subscription: 'number',
  result: notificationResultAndContext(ProgramAccountInfoResult)
});
/**
 * @private
 */

const SlotInfoResult = superstruct.struct({
  parent: 'number',
  slot: 'number',
  root: 'number'
});
/**
 * Expected JSON RPC response for the "slotNotification" message
 */

const SlotNotificationResult = superstruct.struct({
  subscription: 'number',
  result: SlotInfoResult
});
/**
 * Expected JSON RPC response for the "signatureNotification" message
 */

const SignatureNotificationResult = superstruct.struct({
  subscription: 'number',
  result: notificationResultAndContext(SignatureStatusResult)
});
/**
 * Expected JSON RPC response for the "rootNotification" message
 */

const RootNotificationResult = superstruct.struct({
  subscription: 'number',
  result: 'number'
});
/**
 * Expected JSON RPC response for the "getProgramAccounts" message
 */

const GetProgramAccountsRpcResult = jsonRpcResult(superstruct.struct.array([ProgramAccountInfoResult]));
/**
 * Expected JSON RPC response for the "getProgramAccounts" message
 */

const GetParsedProgramAccountsRpcResult = jsonRpcResult(superstruct.struct.array([ParsedProgramAccountInfoResult]));
/**
 * Expected JSON RPC response for the "getSlot" message
 */

const GetSlot = jsonRpcResult('number');
/**
 * Expected JSON RPC response for the "getSlotLeader" message
 */

const GetSlotLeader = jsonRpcResult('string');
/**
 * Expected JSON RPC response for the "getClusterNodes" message
 */

const GetClusterNodes = jsonRpcResult(superstruct.struct.array([superstruct.struct.pick({
  pubkey: 'string',
  gossip: superstruct.struct.union(['null', 'string']),
  tpu: superstruct.struct.union(['null', 'string']),
  rpc: superstruct.struct.union(['null', 'string']),
  version: superstruct.struct.union(['null', 'string'])
})]));
/**
 * Expected JSON RPC response for the "getVoteAccounts" message
 */

const GetVoteAccounts = jsonRpcResult(superstruct.struct({
  current: superstruct.struct.array([superstruct.struct.pick({
    votePubkey: 'string',
    nodePubkey: 'string',
    activatedStake: 'number',
    epochVoteAccount: 'boolean',
    epochCredits: superstruct.struct.array([superstruct.struct.tuple(['number', 'number', 'number'])]),
    commission: 'number',
    lastVote: 'number',
    rootSlot: 'number?'
  })]),
  delinquent: superstruct.struct.array([superstruct.struct.pick({
    votePubkey: 'string',
    nodePubkey: 'string',
    activatedStake: 'number',
    epochVoteAccount: 'boolean',
    epochCredits: superstruct.struct.array([superstruct.struct.tuple(['number', 'number', 'number'])]),
    commission: 'number',
    lastVote: 'number',
    rootSlot: 'number?'
  })])
}));
/**
 * Expected JSON RPC response for the "getSignatureStatuses" message
 */

const GetSignatureStatusesRpcResult = jsonRpcResultAndContext(superstruct.struct.array([superstruct.struct.union(['null', superstruct.struct.pick({
  slot: 'number',
  confirmations: superstruct.struct.union(['number', 'null']),
  err: TransactionErrorResult,
  confirmationStatus: 'string?'
})])]));
/**
 * Expected JSON RPC response for the "getTransactionCount" message
 */

const GetTransactionCountRpcResult = jsonRpcResult('number');
/**
 * Expected JSON RPC response for the "getTotalSupply" message
 */

const GetTotalSupplyRpcResult = jsonRpcResult('number');
/**
 * Expected JSON RPC response for the "getMinimumBalanceForRentExemption" message
 */

const GetMinimumBalanceForRentExemptionRpcResult = jsonRpcResult('number');
/**
 * @private
 */

const ConfirmedTransactionResult = superstruct.struct({
  signatures: superstruct.struct.array(['string']),
  message: superstruct.struct({
    accountKeys: superstruct.struct.array(['string']),
    header: superstruct.struct({
      numRequiredSignatures: 'number',
      numReadonlySignedAccounts: 'number',
      numReadonlyUnsignedAccounts: 'number'
    }),
    instructions: superstruct.struct.array([superstruct.struct({
      accounts: superstruct.struct.array(['number']),
      data: 'string',
      programIdIndex: 'number'
    })]),
    recentBlockhash: 'string'
  })
});
/**
 * @private
 */

const ParsedConfirmedTransactionResult = superstruct.struct({
  signatures: superstruct.struct.array(['string']),
  message: superstruct.struct({
    accountKeys: superstruct.struct.array([superstruct.struct({
      pubkey: 'string',
      signer: 'boolean',
      writable: 'boolean'
    })]),
    instructions: superstruct.struct.array([superstruct.struct.union([superstruct.struct({
      accounts: superstruct.struct.array(['string']),
      data: 'string',
      programId: 'string'
    }), superstruct.struct({
      parsed: 'any',
      program: 'string',
      programId: 'string'
    })])]),
    recentBlockhash: 'string'
  })
});
/**
 * @private
 */

const ConfirmedTransactionMetaResult = superstruct.struct.union(['null', superstruct.struct.pick({
  err: TransactionErrorResult,
  fee: 'number',
  innerInstructions: superstruct.struct.union([superstruct.struct.array([superstruct.struct({
    index: 'number',
    instructions: superstruct.struct.array([superstruct.struct({
      accounts: superstruct.struct.array(['number']),
      data: 'string',
      programIdIndex: 'number'
    })])
  })]), 'null', 'undefined']),
  preBalances: superstruct.struct.array(['number']),
  postBalances: superstruct.struct.array(['number']),
  logMessages: superstruct.struct.union([superstruct.struct.array(['string']), 'null', 'undefined']),
  preTokenBalances: superstruct.struct.union([superstruct.struct.array([superstruct.struct.pick({
    accountIndex: 'number',
    mint: 'string',
    uiTokenAmount: superstruct.struct.pick({
      amount: 'string',
      decimals: 'number',
      uiAmount: 'number'
    })
  })]), 'null', 'undefined']),
  postTokenBalances: superstruct.struct.union([superstruct.struct.array([superstruct.struct.pick({
    accountIndex: 'number',
    mint: 'string',
    uiTokenAmount: superstruct.struct.pick({
      amount: 'string',
      decimals: 'number',
      uiAmount: 'number'
    })
  })]), 'null', 'undefined'])
})]);
/**
 * @private
 */

const ParsedConfirmedTransactionMetaResult = superstruct.struct.union(['null', superstruct.struct.pick({
  err: TransactionErrorResult,
  fee: 'number',
  innerInstructions: superstruct.struct.union([superstruct.struct.array([superstruct.struct({
    index: 'number',
    instructions: superstruct.struct.array([superstruct.struct.union([superstruct.struct({
      accounts: superstruct.struct.array(['string']),
      data: 'string',
      programId: 'string'
    }), superstruct.struct({
      parsed: 'any',
      program: 'string',
      programId: 'string'
    })])])
  })]), 'null', 'undefined']),
  preBalances: superstruct.struct.array(['number']),
  postBalances: superstruct.struct.array(['number']),
  logMessages: superstruct.struct.union([superstruct.struct.array(['string']), 'null', 'undefined']),
  preTokenBalances: superstruct.struct.union([superstruct.struct.array([superstruct.struct.pick({
    accountIndex: 'number',
    mint: 'string',
    uiTokenAmount: superstruct.struct.pick({
      amount: 'string',
      decimals: 'number',
      uiAmount: 'number'
    })
  })]), 'null', 'undefined']),
  postTokenBalances: superstruct.struct.union([superstruct.struct.array([superstruct.struct.pick({
    accountIndex: 'number',
    mint: 'string',
    uiTokenAmount: superstruct.struct.pick({
      amount: 'string',
      decimals: 'number',
      uiAmount: 'number'
    })
  })]), 'null', 'undefined'])
})]);
/**
 * Expected JSON RPC response for the "getConfirmedBlock" message
 */

const GetConfirmedBlockRpcResult = jsonRpcResult(superstruct.struct.union(['null', superstruct.struct.pick({
  blockhash: 'string',
  previousBlockhash: 'string',
  parentSlot: 'number',
  transactions: superstruct.struct.array([superstruct.struct({
    transaction: ConfirmedTransactionResult,
    meta: ConfirmedTransactionMetaResult
  })]),
  rewards: superstruct.struct.union(['undefined', superstruct.struct.array([superstruct.struct({
    pubkey: 'string',
    lamports: 'number',
    postBalance: superstruct.struct.union(['number', 'undefined']),
    rewardType: superstruct.struct.union(['string', 'undefined'])
  })])])
})]));
/**
 * Expected JSON RPC response for the "getConfirmedTransaction" message
 */

const GetConfirmedTransactionRpcResult = jsonRpcResult(superstruct.struct.union(['null', superstruct.struct.pick({
  slot: 'number',
  transaction: ConfirmedTransactionResult,
  meta: ConfirmedTransactionMetaResult,
  blockTime: superstruct.struct.union(['number', 'null', 'undefined'])
})]));
/**
 * Expected JSON RPC response for the "getConfirmedTransaction" message
 */

const GetParsedConfirmedTransactionRpcResult = jsonRpcResult(superstruct.struct.union(['null', superstruct.struct.pick({
  slot: 'number',
  transaction: ParsedConfirmedTransactionResult,
  meta: ParsedConfirmedTransactionMetaResult,
  blockTime: superstruct.struct.union(['number', 'null', 'undefined'])
})]));
/**
 * Expected JSON RPC response for the "getRecentBlockhash" message
 */

const GetRecentBlockhashAndContextRpcResult = jsonRpcResultAndContext(superstruct.struct({
  blockhash: 'string',
  feeCalculator: superstruct.struct({
    lamportsPerSignature: 'number'
  })
}));
/*
 * Expected JSON RPC response for "getRecentPerformanceSamples" message
 */

const GetRecentPerformanceSamplesRpcResult = jsonRpcResult(superstruct.struct.array([superstruct.struct.pick({
  slot: 'number',
  numTransactions: 'number',
  numSlots: 'number',
  samplePeriodSecs: 'number'
})]));
/**
 * Expected JSON RPC response for the "getFeeCalculatorForBlockhash" message
 */

const GetFeeCalculatorRpcResult = jsonRpcResultAndContext(superstruct.struct.union(['null', superstruct.struct({
  feeCalculator: superstruct.struct({
    lamportsPerSignature: 'number'
  })
})]));
/**
 * Expected JSON RPC response for the "requestAirdrop" message
 */

const RequestAirdropRpcResult = jsonRpcResult('string');
/**
 * Expected JSON RPC response for the "sendTransaction" message
 */

const SendTransactionRpcResult = jsonRpcResult('string');
/**
 * Information about the latest slot being processed by a node
 *
 * @typedef {Object} SlotInfo
 * @property {number} slot Currently processing slot
 * @property {number} parent Parent of the current slot
 * @property {number} root The root block of the current slot's fork
 */

/**
 * Parsed account data
 *
 * @typedef {Object} ParsedAccountData
 * @property {string} program Name of the program that owns this account
 * @property {any} parsed Parsed account data
 * @property {number} space Space used by account data
 */

/**
 * Stake Activation data
 *
 * @typedef {Object} StakeActivationData
 * @property {string} state: <string - the stake account's activation state, one of: active, inactive, activating, deactivating
 * @property {number} active: stake active during the epoch
 * @property {number} inactive: stake inactive during the epoch
 */

/**
 * Information describing an account
 *
 * @typedef {Object} AccountInfo
 * @property {number} lamports Number of lamports assigned to the account
 * @property {PublicKey} owner Identifier of the program that owns the account
 * @property {T} data Optional data assigned to the account
 * @property {boolean} executable `true` if this account's data contains a loaded program
 */

/**
 * Account information identified by pubkey
 *
 * @typedef {Object} KeyedAccountInfo
 * @property {PublicKey} accountId
 * @property {AccountInfo<Buffer>} accountInfo
 */

/**
 * Callback function for account change notifications
 */

/**
 * @private
 */

/**
 * @private
 */

/**
 * Callback function for program account change notifications
 */

/**
 * @private
 */

/**
 * Callback function for slot change notifications
 */

/**
 * @private
 */

/**
 * Callback function for signature notifications
 */

/**
 * @private
 */

/**
 * Callback function for root change notifications
 */

/**
 * @private
 */

/**
 * Signature result
 *
 * @typedef {Object} SignatureResult
 */

/**
 * Transaction error
 *
 * @typedef {Object} TransactionError
 */

/**
 * Signature status
 *
 * @typedef {Object} SignatureStatus
 * @property {number} slot when the transaction was processed
 * @property {number | null} confirmations the number of blocks that have been confirmed and voted on in the fork containing `slot` (TODO)
 * @property {TransactionError | null} err error, if any
 * @property {string | null} confirmationStatus the transaction's cluster confirmation status, if data available. Possible non-null responses: `processed`, `confirmed`, `finalized`
 */

/**
 * A confirmed signature with its status
 *
 * @typedef {Object} ConfirmedSignatureInfo
 * @property {string} signature the transaction signature
 * @property {number} slot when the transaction was processed
 * @property {TransactionError | null} err error, if any
 * @property {string | null} memo memo associated with the transaction, if any
 * @property {number | null | undefined} blockTime The unix timestamp of when the transaction was processed
 */

/**
 * A connection to a fullnode JSON RPC endpoint
 */

class Connection {
  /**
   * Establish a JSON RPC connection
   *
   * @param endpoint URL to the fullnode JSON RPC endpoint
   * @param commitment optional default commitment level
   */
  constructor(endpoint, commitment) {
    _defineProperty__default['default'](this, "_rpcEndpoint", void 0);

    _defineProperty__default['default'](this, "_rpcRequest", void 0);

    _defineProperty__default['default'](this, "_rpcWebSocket", void 0);

    _defineProperty__default['default'](this, "_rpcWebSocketConnected", false);

    _defineProperty__default['default'](this, "_rpcWebSocketHeartbeat", null);

    _defineProperty__default['default'](this, "_rpcWebSocketIdleTimeout", null);

    _defineProperty__default['default'](this, "_commitment", void 0);

    _defineProperty__default['default'](this, "_blockhashInfo", void 0);

    _defineProperty__default['default'](this, "_disableBlockhashCaching", false);

    _defineProperty__default['default'](this, "_pollingBlockhash", false);

    _defineProperty__default['default'](this, "_accountChangeSubscriptions", {});

    _defineProperty__default['default'](this, "_accountChangeSubscriptionCounter", 0);

    _defineProperty__default['default'](this, "_programAccountChangeSubscriptions", {});

    _defineProperty__default['default'](this, "_programAccountChangeSubscriptionCounter", 0);

    _defineProperty__default['default'](this, "_slotSubscriptions", {});

    _defineProperty__default['default'](this, "_slotSubscriptionCounter", 0);

    _defineProperty__default['default'](this, "_signatureSubscriptions", {});

    _defineProperty__default['default'](this, "_signatureSubscriptionCounter", 0);

    _defineProperty__default['default'](this, "_rootSubscriptions", {});

    _defineProperty__default['default'](this, "_rootSubscriptionCounter", 0);

    this._rpcEndpoint = endpoint;
    let url$1 = url.parse(endpoint);
    const useHttps = url$1.protocol === 'https:';
    this._rpcRequest = createRpcRequest(url$1.href, useHttps);
    this._commitment = commitment;
    this._blockhashInfo = {
      recentBlockhash: null,
      lastFetch: new Date(0),
      transactionSignatures: [],
      simulatedSignatures: []
    };
    url$1.protocol = useHttps ? 'wss:' : 'ws:';
    url$1.host = ''; // Only shift the port by +1 as a convention for ws(s) only if given endpoint
    // is explictly specifying the endpoint port (HTTP-based RPC), assuming
    // we're directly trying to connect to solana-validator's ws listening port.
    // When the endpoint omits the port, we're connecting to the protocol
    // default ports: http(80) or https(443) and it's assumed we're behind a reverse
    // proxy which manages WebSocket upgrade and backend port redirection.

    if (url$1.port !== null) {
      url$1.port = String(Number(url$1.port) + 1);
    }

    this._rpcWebSocket = new rpcWebsockets.Client(url.format(url$1), {
      autoconnect: false,
      max_reconnects: Infinity
    });

    this._rpcWebSocket.on('open', this._wsOnOpen.bind(this));

    this._rpcWebSocket.on('error', this._wsOnError.bind(this));

    this._rpcWebSocket.on('close', this._wsOnClose.bind(this));

    this._rpcWebSocket.on('accountNotification', this._wsOnAccountNotification.bind(this));

    this._rpcWebSocket.on('programNotification', this._wsOnProgramAccountNotification.bind(this));

    this._rpcWebSocket.on('slotNotification', this._wsOnSlotNotification.bind(this));

    this._rpcWebSocket.on('signatureNotification', this._wsOnSignatureNotification.bind(this));

    this._rpcWebSocket.on('rootNotification', this._wsOnRootNotification.bind(this));
  }
  /**
   * The default commitment used for requests
   */


  get commitment() {
    return this._commitment;
  }
  /**
   * Fetch the balance for the specified public key, return with context
   */


  async getBalanceAndContext(publicKey, commitment) {
    const args = this._buildArgs([publicKey.toBase58()], commitment);

    const unsafeRes = await this._rpcRequest('getBalance', args);
    const res = GetBalanceAndContextRpcResult(unsafeRes);

    if (res.error) {
      throw new Error('failed to get balance for ' + publicKey.toBase58() + ': ' + res.error.message);
    }

    assert__default['default'](typeof res.result !== 'undefined');
    return res.result;
  }
  /**
   * Fetch the balance for the specified public key
   */


  async getBalance(publicKey, commitment) {
    return await this.getBalanceAndContext(publicKey, commitment).then(x => x.value).catch(e => {
      throw new Error('failed to get balance of account ' + publicKey.toBase58() + ': ' + e);
    });
  }
  /**
   * Fetch the estimated production time of a block
   */


  async getBlockTime(slot) {
    const unsafeRes = await this._rpcRequest('getBlockTime', [slot]);
    const res = GetBlockTimeRpcResult(unsafeRes);

    if (res.error) {
      throw new Error('failed to get block time for slot ' + slot + ': ' + res.error.message);
    }

    assert__default['default'](typeof res.result !== 'undefined');
    return res.result;
  }
  /**
   * Fetch the lowest slot that the node has information about in its ledger.
   * This value may increase over time if the node is configured to purge older ledger data
   */


  async getMinimumLedgerSlot() {
    const unsafeRes = await this._rpcRequest('minimumLedgerSlot', []);
    const res = SlotRpcResult(unsafeRes);

    if (res.error) {
      throw new Error('failed to get minimum ledger slot: ' + res.error.message);
    }

    assert__default['default'](typeof res.result !== 'undefined');
    return res.result;
  }
  /**
   * Fetch the slot of the lowest confirmed block that has not been purged from the ledger
   */


  async getFirstAvailableBlock() {
    const unsafeRes = await this._rpcRequest('getFirstAvailableBlock', []);
    const res = SlotRpcResult(unsafeRes);

    if (res.error) {
      throw new Error('failed to get first available block: ' + res.error.message);
    }

    assert__default['default'](typeof res.result !== 'undefined');
    return res.result;
  }
  /**
   * Fetch information about the current supply
   */


  async getSupply(commitment) {
    const args = this._buildArgs([], commitment);

    const unsafeRes = await this._rpcRequest('getSupply', args);
    const res = GetSupplyRpcResult(unsafeRes);

    if (res.error) {
      throw new Error('failed to get supply: ' + res.error.message);
    }

    assert__default['default'](typeof res.result !== 'undefined');
    res.result.value.nonCirculatingAccounts = res.result.value.nonCirculatingAccounts.map(account => new PublicKey(account));
    return res.result;
  }
  /**
   * Fetch the current supply of a token mint
   */


  async getTokenSupply(tokenMintAddress, commitment) {
    const args = this._buildArgs([tokenMintAddress.toBase58()], commitment);

    const unsafeRes = await this._rpcRequest('getTokenSupply', args);
    const res = GetTokenSupplyRpcResult(unsafeRes);

    if (res.error) {
      throw new Error('failed to get token supply: ' + res.error.message);
    }

    assert__default['default'](typeof res.result !== 'undefined');
    return res.result;
  }
  /**
   * Fetch the current balance of a token account
   */


  async getTokenAccountBalance(tokenAddress, commitment) {
    const args = this._buildArgs([tokenAddress.toBase58()], commitment);

    const unsafeRes = await this._rpcRequest('getTokenAccountBalance', args);
    const res = GetTokenAccountBalance(unsafeRes);

    if (res.error) {
      throw new Error('failed to get token account balance: ' + res.error.message);
    }

    assert__default['default'](typeof res.result !== 'undefined');
    return res.result;
  }
  /**
   * Fetch all the token accounts owned by the specified account
   *
   * @return {Promise<RpcResponseAndContext<Array<{pubkey: PublicKey, account: AccountInfo<Buffer>}>>>}
   */


  async getTokenAccountsByOwner(ownerAddress, filter, commitment) {
    let _args = [ownerAddress.toBase58()];

    if (filter.mint) {
      _args.push({
        mint: filter.mint.toBase58()
      });
    } else {
      _args.push({
        programId: filter.programId.toBase58()
      });
    }

    const args = this._buildArgs(_args, commitment, 'base64');

    const unsafeRes = await this._rpcRequest('getTokenAccountsByOwner', args);
    const res = GetTokenAccountsByOwner(unsafeRes);

    if (res.error) {
      throw new Error('failed to get token accounts owned by account ' + ownerAddress.toBase58() + ': ' + res.error.message);
    }

    const {
      result
    } = res;
    const {
      context,
      value
    } = result;
    assert__default['default'](typeof result !== 'undefined');
    return {
      context,
      value: value.map(result => {
        assert__default['default'](result.account.data[1] === 'base64');
        return {
          pubkey: new PublicKey(result.pubkey),
          account: {
            executable: result.account.executable,
            owner: new PublicKey(result.account.owner),
            lamports: result.account.lamports,
            data: buffer.Buffer.from(result.account.data[0], 'base64')
          }
        };
      })
    };
  }
  /**
   * Fetch parsed token accounts owned by the specified account
   *
   * @return {Promise<RpcResponseAndContext<Array<{pubkey: PublicKey, account: AccountInfo<ParsedAccountData>}>>>}
   */


  async getParsedTokenAccountsByOwner(ownerAddress, filter, commitment) {
    let _args = [ownerAddress.toBase58()];

    if (filter.mint) {
      _args.push({
        mint: filter.mint.toBase58()
      });
    } else {
      _args.push({
        programId: filter.programId.toBase58()
      });
    }

    const args = this._buildArgs(_args, commitment, 'jsonParsed');

    const unsafeRes = await this._rpcRequest('getTokenAccountsByOwner', args);
    const res = GetParsedTokenAccountsByOwner(unsafeRes);

    if (res.error) {
      throw new Error('failed to get token accounts owned by account ' + ownerAddress.toBase58() + ': ' + res.error.message);
    }

    const {
      result
    } = res;
    const {
      context,
      value
    } = result;
    assert__default['default'](typeof result !== 'undefined');
    return {
      context,
      value: value.map(result => ({
        pubkey: new PublicKey(result.pubkey),
        account: {
          executable: result.account.executable,
          owner: new PublicKey(result.account.owner),
          lamports: result.account.lamports,
          data: result.account.data
        }
      }))
    };
  }
  /**
   * Fetch the 20 largest accounts with their current balances
   */


  async getLargestAccounts(config) {
    const arg = { ...config,
      commitment: config && config.commitment || this.commitment
    };
    const args = arg.filter || arg.commitment ? [arg] : [];
    const unsafeRes = await this._rpcRequest('getLargestAccounts', args);
    const res = GetLargestAccountsRpcResult(unsafeRes);

    if (res.error) {
      throw new Error('failed to get largest accounts: ' + res.error.message);
    }

    assert__default['default'](typeof res.result !== 'undefined');
    res.result.value = res.result.value.map(({
      address,
      lamports
    }) => ({
      address: new PublicKey(address),
      lamports
    }));
    return res.result;
  }
  /**
   * Fetch the 20 largest token accounts with their current balances
   * for a given mint.
   */


  async getTokenLargestAccounts(mintAddress, commitment) {
    const args = this._buildArgs([mintAddress.toBase58()], commitment);

    const unsafeRes = await this._rpcRequest('getTokenLargestAccounts', args);
    const res = GetTokenLargestAccountsResult(unsafeRes);

    if (res.error) {
      throw new Error('failed to get token largest accounts: ' + res.error.message);
    }

    assert__default['default'](typeof res.result !== 'undefined');
    res.result.value = res.result.value.map(pair => ({ ...pair,
      address: new PublicKey(pair.address)
    }));
    return res.result;
  }
  /**
   * Fetch all the account info for the specified public key, return with context
   */


  async getAccountInfoAndContext(publicKey, commitment) {
    const args = this._buildArgs([publicKey.toBase58()], commitment, 'base64');

    const unsafeRes = await this._rpcRequest('getAccountInfo', args);
    const res = GetAccountInfoAndContextRpcResult(unsafeRes);

    if (res.error) {
      throw new Error('failed to get info about account ' + publicKey.toBase58() + ': ' + res.error.message);
    }

    assert__default['default'](typeof res.result !== 'undefined');
    let value = null;

    if (res.result.value) {
      const {
        executable,
        owner,
        lamports,
        data
      } = res.result.value;
      assert__default['default'](data[1] === 'base64');
      value = {
        executable,
        owner: new PublicKey(owner),
        lamports,
        data: buffer.Buffer.from(data[0], 'base64')
      };
    }

    return {
      context: {
        slot: res.result.context.slot
      },
      value
    };
  }
  /**
   * Fetch parsed account info for the specified public key
   */


  async getParsedAccountInfo(publicKey, commitment) {
    const args = this._buildArgs([publicKey.toBase58()], commitment, 'jsonParsed');

    const unsafeRes = await this._rpcRequest('getAccountInfo', args);
    const res = GetParsedAccountInfoResult(unsafeRes);

    if (res.error) {
      throw new Error('failed to get info about account ' + publicKey.toBase58() + ': ' + res.error.message);
    }

    assert__default['default'](typeof res.result !== 'undefined');
    let value = null;

    if (res.result.value) {
      const {
        executable,
        owner,
        lamports,
        data: resultData
      } = res.result.value;
      let data = resultData;

      if (!data.program) {
        assert__default['default'](data[1] === 'base64');
        data = buffer.Buffer.from(data[0], 'base64');
      }

      value = {
        executable,
        owner: new PublicKey(owner),
        lamports,
        data
      };
    }

    return {
      context: {
        slot: res.result.context.slot
      },
      value
    };
  }
  /**
   * Fetch all the account info for the specified public key
   */


  async getAccountInfo(publicKey, commitment) {
    return await this.getAccountInfoAndContext(publicKey, commitment).then(x => x.value).catch(e => {
      throw new Error('failed to get info about account ' + publicKey.toBase58() + ': ' + e);
    });
  }
  /**
   * Returns epoch activation information for a stake account that has been delegated
   */


  async getStakeActivation(publicKey, commitment, epoch) {
    const args = this._buildArgs([publicKey.toBase58()], commitment, undefined, epoch !== undefined ? {
      epoch
    } : undefined);

    const unsafeRes = await this._rpcRequest('getStakeActivation', args);
    const res = GetStakeActivationResult(unsafeRes);

    if (res.error) {
      throw new Error(`failed to get Stake Activation ${publicKey.toBase58()}: ${res.error.message}`);
    }

    assert__default['default'](typeof res.result !== 'undefined');
    const {
      state,
      active,
      inactive
    } = res.result;
    return {
      state,
      active,
      inactive
    };
  }
  /**
   * Fetch all the accounts owned by the specified program id
   *
   * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer>}>>}
   */


  async getProgramAccounts(programId, commitment) {
    const args = this._buildArgs([programId.toBase58()], commitment, 'base64');

    const unsafeRes = await this._rpcRequest('getProgramAccounts', args);
    const res = GetProgramAccountsRpcResult(unsafeRes);

    if (res.error) {
      throw new Error('failed to get accounts owned by program ' + programId.toBase58() + ': ' + res.error.message);
    }

    const {
      result
    } = res;
    assert__default['default'](typeof result !== 'undefined');
    return result.map(result => {
      assert__default['default'](result.account.data[1] === 'base64');
      return {
        pubkey: new PublicKey(result.pubkey),
        account: {
          executable: result.account.executable,
          owner: new PublicKey(result.account.owner),
          lamports: result.account.lamports,
          data: buffer.Buffer.from(result.account.data[0], 'base64')
        }
      };
    });
  }
  /**
   * Fetch and parse all the accounts owned by the specified program id
   *
   * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer | ParsedAccountData>}>>}
   */


  async getParsedProgramAccounts(programId, commitment) {
    const args = this._buildArgs([programId.toBase58()], commitment, 'jsonParsed');

    const unsafeRes = await this._rpcRequest('getProgramAccounts', args);
    const res = GetParsedProgramAccountsRpcResult(unsafeRes);

    if (res.error) {
      throw new Error('failed to get accounts owned by program ' + programId.toBase58() + ': ' + res.error.message);
    }

    const {
      result
    } = res;
    assert__default['default'](typeof result !== 'undefined');
    return result.map(result => {
      const resultData = result.account.data;
      let data = resultData;

      if (!data.program) {
        assert__default['default'](data[1] === 'base64');
        data = buffer.Buffer.from(data[0], 'base64');
      }

      return {
        pubkey: new PublicKey(result.pubkey),
        account: {
          executable: result.account.executable,
          owner: new PublicKey(result.account.owner),
          lamports: result.account.lamports,
          data
        }
      };
    });
  }
  /**
   * Confirm the transaction identified by the specified signature.
   */


  async confirmTransaction(signature, commitment) {
    let decodedSignature;

    try {
      decodedSignature = bs58__default['default'].decode(signature);
    } catch (err) {
      throw new Error('signature must be base58 encoded: ' + signature);
    }

    assert__default['default'](decodedSignature.length === 64, 'signature has invalid length');
    const start = Date.now();
    const subscriptionCommitment = commitment || this.commitment;
    let subscriptionId;
    let response = null;
    const confirmPromise = new Promise((resolve, reject) => {
      try {
        subscriptionId = this.onSignature(signature, (result, context) => {
          subscriptionId = undefined;
          response = {
            context,
            value: result
          };
          resolve();
        }, subscriptionCommitment);
      } catch (err) {
        reject(err);
      }
    });
    let timeoutMs = 60 * 1000;

    switch (subscriptionCommitment) {
      case 'recent':
      case 'single':
      case 'singleGossip':
        {
          timeoutMs = 30 * 1000;
          break;
        }
    }

    try {
      await promiseTimeout(confirmPromise, timeoutMs);
    } finally {
      if (subscriptionId) {
        this.removeSignatureListener(subscriptionId);
      }
    }

    if (response === null) {
      const duration = (Date.now() - start) / 1000;
      throw new Error(`Transaction was not confirmed in ${duration.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${signature} using the Solana Explorer or CLI tools.`);
    }

    return response;
  }
  /**
   * Return the list of nodes that are currently participating in the cluster
   */


  async getClusterNodes() {
    const unsafeRes = await this._rpcRequest('getClusterNodes', []);
    const res = GetClusterNodes(unsafeRes);

    if (res.error) {
      throw new Error('failed to get cluster nodes: ' + res.error.message);
    }

    assert__default['default'](typeof res.result !== 'undefined');
    return res.result;
  }
  /**
   * Return the list of nodes that are currently participating in the cluster
   */


  async getVoteAccounts(commitment) {
    const args = this._buildArgs([], commitment);

    const unsafeRes = await this._rpcRequest('getVoteAccounts', args);
    const res = GetVoteAccounts(unsafeRes); //const res = unsafeRes;

    if (res.error) {
      throw new Error('failed to get vote accounts: ' + res.error.message);
    }

    assert__default['default'](typeof res.result !== 'undefined');
    return res.result;
  }
  /**
   * Fetch the current slot that the node is processing
   */


  async getSlot(commitment) {
    const args = this._buildArgs([], commitment);

    const unsafeRes = await this._rpcRequest('getSlot', args);
    const res = GetSlot(unsafeRes);

    if (res.error) {
      throw new Error('failed to get slot: ' + res.error.message);
    }

    assert__default['default'](typeof res.result !== 'undefined');
    return res.result;
  }
  /**
   * Fetch the current slot leader of the cluster
   */


  async getSlotLeader(commitment) {
    const args = this._buildArgs([], commitment);

    const unsafeRes = await this._rpcRequest('getSlotLeader', args);
    const res = GetSlotLeader(unsafeRes);

    if (res.error) {
      throw new Error('failed to get slot leader: ' + res.error.message);
    }

    assert__default['default'](typeof res.result !== 'undefined');
    return res.result;
  }
  /**
   * Fetch the current status of a signature
   */


  async getSignatureStatus(signature, config) {
    const {
      context,
      value
    } = await this.getSignatureStatuses([signature], config);
    assert__default['default'](value.length === 1);
    return {
      context,
      value: value[0]
    };
  }
  /**
   * Fetch the current statuses of a batch of signatures
   */


  async getSignatureStatuses(signatures, config) {
    const params = [signatures];

    if (config) {
      params.push(config);
    }

    const unsafeRes = await this._rpcRequest('getSignatureStatuses', params);
    const res = GetSignatureStatusesRpcResult(unsafeRes);

    if (res.error) {
      throw new Error('failed to get signature status: ' + res.error.message);
    }

    assert__default['default'](typeof res.result !== 'undefined');
    return res.result;
  }
  /**
   * Fetch the current transaction count of the cluster
   */


  async getTransactionCount(commitment) {
    const args = this._buildArgs([], commitment);

    const unsafeRes = await this._rpcRequest('getTransactionCount', args);
    const res = GetTransactionCountRpcResult(unsafeRes);

    if (res.error) {
      throw new Error('failed to get transaction count: ' + res.error.message);
    }

    assert__default['default'](typeof res.result !== 'undefined');
    return Number(res.result);
  }
  /**
   * Fetch the current total currency supply of the cluster in lamports
   */


  async getTotalSupply(commitment) {
    const args = this._buildArgs([], commitment);

    const unsafeRes = await this._rpcRequest('getTotalSupply', args);
    const res = GetTotalSupplyRpcResult(unsafeRes);

    if (res.error) {
      throw new Error('faied to get total supply: ' + res.error.message);
    }

    assert__default['default'](typeof res.result !== 'undefined');
    return Number(res.result);
  }
  /**
   * Fetch the cluster InflationGovernor parameters
   */


  async getInflationGovernor(commitment) {
    const args = this._buildArgs([], commitment);

    const unsafeRes = await this._rpcRequest('getInflationGovernor', args);
    const res = GetInflationGovernorRpcResult(unsafeRes);

    if (res.error) {
      throw new Error('failed to get inflation: ' + res.error.message);
    }

    assert__default['default'](typeof res.result !== 'undefined');
    return GetInflationGovernorResult(res.result);
  }
  /**
   * Fetch the Epoch Info parameters
   */


  async getEpochInfo(commitment) {
    const args = this._buildArgs([], commitment);

    const unsafeRes = await this._rpcRequest('getEpochInfo', args);
    const res = GetEpochInfoRpcResult(unsafeRes);

    if (res.error) {
      throw new Error('failed to get epoch info: ' + res.error.message);
    }

    assert__default['default'](typeof res.result !== 'undefined');
    return GetEpochInfoResult(res.result);
  }
  /**
   * Fetch the Epoch Schedule parameters
   */


  async getEpochSchedule() {
    const unsafeRes = await this._rpcRequest('getEpochSchedule', []);
    const res = GetEpochScheduleRpcResult(unsafeRes);

    if (res.error) {
      throw new Error('failed to get epoch schedule: ' + res.error.message);
    }

    assert__default['default'](typeof res.result !== 'undefined');
    return GetEpochScheduleResult(res.result);
  }
  /**
   * Fetch the leader schedule for the current epoch
   * @return {Promise<RpcResponseAndContext<LeaderSchedule>>}
   */


  async getLeaderSchedule() {
    const unsafeRes = await this._rpcRequest('getLeaderSchedule', []);
    const res = GetLeaderScheduleRpcResult(unsafeRes);

    if (res.error) {
      throw new Error('failed to get leader schedule: ' + res.error.message);
    }

    assert__default['default'](typeof res.result !== 'undefined');
    return res.result;
  }
  /**
   * Fetch the minimum balance needed to exempt an account of `dataLength`
   * size from rent
   */


  async getMinimumBalanceForRentExemption(dataLength, commitment) {
    const args = this._buildArgs([dataLength], commitment);

    const unsafeRes = await this._rpcRequest('getMinimumBalanceForRentExemption', args);
    const res = GetMinimumBalanceForRentExemptionRpcResult(unsafeRes);

    if (res.error) {
      console.warn('Unable to fetch minimum balance for rent exemption');
      return 0;
    }

    assert__default['default'](typeof res.result !== 'undefined');
    return Number(res.result);
  }
  /**
   * Fetch a recent blockhash from the cluster, return with context
   * @return {Promise<RpcResponseAndContext<{blockhash: Blockhash, feeCalculator: FeeCalculator}>>}
   */


  async getRecentBlockhashAndContext(commitment) {
    const args = this._buildArgs([], commitment);

    const unsafeRes = await this._rpcRequest('getRecentBlockhash', args);
    const res = GetRecentBlockhashAndContextRpcResult(unsafeRes);

    if (res.error) {
      throw new Error('failed to get recent blockhash: ' + res.error.message);
    }

    assert__default['default'](typeof res.result !== 'undefined');
    return res.result;
  }
  /**
   * Fetch recent performance samples
   * @return {Promise<Array<PerfSample>>}
   */


  async getRecentPerformanceSamples(limit) {
    const args = this._buildArgs(limit ? [limit] : []);

    const unsafeRes = await this._rpcRequest('getRecentPerformanceSamples', args);
    const res = GetRecentPerformanceSamplesRpcResult(unsafeRes);

    if (res.error) {
      throw new Error('failed to get recent performance samples: ' + res.error.message);
    }

    assert__default['default'](typeof res.result !== 'undefined');
    return res.result;
  }
  /**
   * Fetch the fee calculator for a recent blockhash from the cluster, return with context
   */


  async getFeeCalculatorForBlockhash(blockhash, commitment) {
    const args = this._buildArgs([blockhash], commitment);

    const unsafeRes = await this._rpcRequest('getFeeCalculatorForBlockhash', args);
    const res = GetFeeCalculatorRpcResult(unsafeRes);

    if (res.error) {
      throw new Error('failed to get fee calculator: ' + res.error.message);
    }

    assert__default['default'](typeof res.result !== 'undefined');
    const {
      context,
      value
    } = res.result;
    return {
      context,
      value: value && value.feeCalculator
    };
  }
  /**
   * Fetch a recent blockhash from the cluster
   * @return {Promise<{blockhash: Blockhash, feeCalculator: FeeCalculator}>}
   */


  async getRecentBlockhash(commitment) {
    return await this.getRecentBlockhashAndContext(commitment).then(x => x.value).catch(e => {
      throw new Error('failed to get recent blockhash: ' + e);
    });
  }
  /**
   * Fetch the node version
   */


  async getVersion() {
    const unsafeRes = await this._rpcRequest('getVersion', []);
    const res = GetVersionRpcResult(unsafeRes);

    if (res.error) {
      throw new Error('failed to get version: ' + res.error.message);
    }

    assert__default['default'](typeof res.result !== 'undefined');
    return res.result;
  }
  /**
   * Fetch a list of Transactions and transaction statuses from the cluster
   * for a confirmed block
   */


  async getConfirmedBlock(slot) {
    const unsafeRes = await this._rpcRequest('getConfirmedBlock', [slot]);
    const res = GetConfirmedBlockRpcResult(unsafeRes);

    if (res.error) {
      throw new Error('failed to get confirmed block: ' + res.error.message);
    }

    const result = res.result;
    assert__default['default'](typeof result !== 'undefined');

    if (!result) {
      throw new Error('Confirmed block ' + slot + ' not found');
    }

    return {
      blockhash: new PublicKey(result.blockhash).toString(),
      previousBlockhash: new PublicKey(result.previousBlockhash).toString(),
      parentSlot: result.parentSlot,
      transactions: result.transactions.map(result => {
        const {
          message,
          signatures
        } = result.transaction;
        return {
          transaction: Transaction.populate(new Message(message), signatures),
          meta: result.meta
        };
      }),
      rewards: result.rewards || []
    };
  }
  /**
   * Fetch a transaction details for a confirmed transaction
   */


  async getConfirmedTransaction(signature) {
    const unsafeRes = await this._rpcRequest('getConfirmedTransaction', [signature]);
    const {
      result,
      error
    } = GetConfirmedTransactionRpcResult(unsafeRes);

    if (error) {
      throw new Error('failed to get confirmed transaction: ' + error.message);
    }

    assert__default['default'](typeof result !== 'undefined');

    if (result === null) {
      return result;
    }

    const {
      message,
      signatures
    } = result.transaction;
    return {
      slot: result.slot,
      transaction: Transaction.populate(new Message(message), signatures),
      meta: result.meta
    };
  }
  /**
   * Fetch parsed transaction details for a confirmed transaction
   */


  async getParsedConfirmedTransaction(signature) {
    const unsafeRes = await this._rpcRequest('getConfirmedTransaction', [signature, 'jsonParsed']);
    const {
      result,
      error
    } = GetParsedConfirmedTransactionRpcResult(unsafeRes);

    if (error) {
      throw new Error('failed to get confirmed transaction: ' + error.message);
    }

    assert__default['default'](typeof result !== 'undefined');
    if (result === null) return result;

    if (result.meta.innerInstructions) {
      result.meta.innerInstructions.forEach(inner => {
        inner.instructions.forEach(ix => {
          ix.programId = new PublicKey(ix.programId);

          if (ix.accounts) {
            ix.accounts = ix.accounts.map(account => new PublicKey(account));
          }
        });
      });
    }

    const {
      accountKeys,
      instructions,
      recentBlockhash
    } = result.transaction.message;
    return {
      slot: result.slot,
      meta: result.meta,
      transaction: {
        signatures: result.transaction.signatures,
        message: {
          accountKeys: accountKeys.map(accountKey => ({
            pubkey: new PublicKey(accountKey.pubkey),
            signer: accountKey.signer,
            writable: accountKey.writable
          })),
          instructions: instructions.map(ix => {
            let mapped = {
              programId: new PublicKey(ix.programId)
            };

            if ('accounts' in ix) {
              mapped.accounts = ix.accounts.map(key => new PublicKey(key));
            }

            return { ...ix,
              ...mapped
            };
          }),
          recentBlockhash
        }
      }
    };
  }
  /**
   * Fetch a list of all the confirmed signatures for transactions involving an address
   * within a specified slot range. Max range allowed is 10,000 slots.
   *
   * @param address queried address
   * @param startSlot start slot, inclusive
   * @param endSlot end slot, inclusive
   */


  async getConfirmedSignaturesForAddress(address, startSlot, endSlot) {
    const unsafeRes = await this._rpcRequest('getConfirmedSignaturesForAddress', [address.toBase58(), startSlot, endSlot]);
    const result = GetConfirmedSignaturesForAddressRpcResult(unsafeRes);

    if (result.error) {
      throw new Error('failed to get confirmed signatures for address: ' + result.error.message);
    }

    assert__default['default'](typeof result.result !== 'undefined');
    return result.result;
  }
  /**
   * Returns confirmed signatures for transactions involving an
   * address backwards in time from the provided signature or most recent confirmed block
   *
   *
   * @param address queried address
   * @param options
   */


  async getConfirmedSignaturesForAddress2(address, options) {
    const unsafeRes = await this._rpcRequest('getConfirmedSignaturesForAddress2', [address.toBase58(), options]);
    const result = GetConfirmedSignaturesForAddress2RpcResult(unsafeRes);

    if (result.error) {
      throw new Error('failed to get confirmed signatures for address: ' + result.error.message);
    }

    assert__default['default'](typeof result.result !== 'undefined');
    return result.result;
  }
  /**
   * Fetch the contents of a Nonce account from the cluster, return with context
   */


  async getNonceAndContext(nonceAccount, commitment) {
    const {
      context,
      value: accountInfo
    } = await this.getAccountInfoAndContext(nonceAccount, commitment);
    let value = null;

    if (accountInfo !== null) {
      value = NonceAccount.fromAccountData(accountInfo.data);
    }

    return {
      context,
      value
    };
  }
  /**
   * Fetch the contents of a Nonce account from the cluster
   */


  async getNonce(nonceAccount, commitment) {
    return await this.getNonceAndContext(nonceAccount, commitment).then(x => x.value).catch(e => {
      throw new Error('failed to get nonce for account ' + nonceAccount.toBase58() + ': ' + e);
    });
  }
  /**
   * Request an allocation of lamports to the specified account
   */


  async requestAirdrop(to, amount) {
    const unsafeRes = await this._rpcRequest('requestAirdrop', [to.toBase58(), amount]);
    const res = RequestAirdropRpcResult(unsafeRes);

    if (res.error) {
      throw new Error('airdrop to ' + to.toBase58() + ' failed: ' + res.error.message);
    }

    assert__default['default'](typeof res.result !== 'undefined');
    return res.result;
  }

  async _recentBlockhash(disableCache) {
    if (!disableCache) {
      // Wait for polling to finish
      while (this._pollingBlockhash) {
        await sleep(100);
      } // Attempt to use a recent blockhash for up to 30 seconds


      const expired = Date.now() - this._blockhashInfo.lastFetch >= BLOCKHASH_CACHE_TIMEOUT_MS;

      if (this._blockhashInfo.recentBlockhash !== null && !expired) {
        return this._blockhashInfo.recentBlockhash;
      }
    }

    return await this._pollNewBlockhash();
  }

  async _pollNewBlockhash() {
    this._pollingBlockhash = true;

    try {
      const startTime = Date.now();

      for (let i = 0; i < 50; i++) {
        const {
          blockhash
        } = await this.getRecentBlockhash('max');

        if (this._blockhashInfo.recentBlockhash != blockhash) {
          this._blockhashInfo = {
            recentBlockhash: blockhash,
            lastFetch: new Date(),
            transactionSignatures: [],
            simulatedSignatures: []
          };
          return blockhash;
        } // Sleep for approximately half a slot


        await sleep(MS_PER_SLOT / 2);
      }

      throw new Error(`Unable to obtain a new blockhash after ${Date.now() - startTime}ms`);
    } finally {
      this._pollingBlockhash = false;
    }
  }
  /**
   * Simulate a transaction
   */


  async simulateTransaction(transaction, signers) {
    if (transaction.nonceInfo && signers) {
      transaction.sign(...signers);
    } else {
      let disableCache = this._disableBlockhashCaching;

      for (;;) {
        transaction.recentBlockhash = await this._recentBlockhash(disableCache);
        if (!signers) break;
        transaction.sign(...signers);

        if (!transaction.signature) {
          throw new Error('!signature'); // should never happen
        } // If the signature of this transaction has not been seen before with the
        // current recentBlockhash, all done.


        const signature = transaction.signature.toString('base64');

        if (!this._blockhashInfo.simulatedSignatures.includes(signature) && !this._blockhashInfo.transactionSignatures.includes(signature)) {
          this._blockhashInfo.simulatedSignatures.push(signature);

          break;
        } else {
          disableCache = true;
        }
      }
    }

    const signData = transaction.serializeMessage();

    const wireTransaction = transaction._serialize(signData);

    const encodedTransaction = wireTransaction.toString('base64');
    const config = {
      encoding: 'base64',
      commitment: this.commitment
    };
    const args = [encodedTransaction, config];

    if (signers) {
      config.sigVerify = true;
    }

    const unsafeRes = await this._rpcRequest('simulateTransaction', args);
    const res = SimulatedTransactionResponseValidator(unsafeRes);

    if (res.error) {
      throw new Error('failed to simulate transaction: ' + res.error.message);
    }

    assert__default['default'](typeof res.result !== 'undefined');
    assert__default['default'](res.result);
    return res.result;
  }
  /**
   * Sign and send a transaction
   */


  async sendTransaction(transaction, signers, options) {
    if (transaction.nonceInfo) {
      transaction.sign(...signers);
    } else {
      let disableCache = this._disableBlockhashCaching;

      for (;;) {
        transaction.recentBlockhash = await this._recentBlockhash(disableCache);
        transaction.sign(...signers);

        if (!transaction.signature) {
          throw new Error('!signature'); // should never happen
        } // If the signature of this transaction has not been seen before with the
        // current recentBlockhash, all done.


        const signature = transaction.signature.toString('base64');

        if (!this._blockhashInfo.transactionSignatures.includes(signature)) {
          this._blockhashInfo.transactionSignatures.push(signature);

          break;
        } else {
          disableCache = true;
        }
      }
    }

    const wireTransaction = transaction.serialize();
    return await this.sendRawTransaction(wireTransaction, options);
  }
  /**
   * @private
   */


  async validatorExit() {
    const unsafeRes = await this._rpcRequest('validatorExit', []);
    const res = jsonRpcResult('boolean')(unsafeRes);

    if (res.error) {
      throw new Error('validator exit failed: ' + res.error.message);
    }

    assert__default['default'](typeof res.result !== 'undefined');
    return res.result;
  }
  /**
   * Send a transaction that has already been signed and serialized into the
   * wire format
   */


  async sendRawTransaction(rawTransaction, options) {
    const encodedTransaction = toBuffer(rawTransaction).toString('base64');
    const result = await this.sendEncodedTransaction(encodedTransaction, options);
    return result;
  }
  /**
   * Send a transaction that has already been signed, serialized into the
   * wire format, and encoded as a base64 string
   */


  async sendEncodedTransaction(encodedTransaction, options) {
    const config = {
      encoding: 'base64'
    };
    const args = [encodedTransaction, config];
    const skipPreflight = options && options.skipPreflight;
    const preflightCommitment = options && options.preflightCommitment || this.commitment;

    if (skipPreflight) {
      config.skipPreflight = skipPreflight;
    }

    if (preflightCommitment) {
      config.preflightCommitment = preflightCommitment;
    }

    const unsafeRes = await this._rpcRequest('sendTransaction', args);
    const res = SendTransactionRpcResult(unsafeRes);

    if (res.error) {
      if (res.error.data) {
        const logs = res.error.data.logs;

        if (logs && Array.isArray(logs)) {
          const traceIndent = '\n    ';
          const logTrace = traceIndent + logs.join(traceIndent);
          console.error(res.error.message, logTrace);
        }
      }

      throw new Error('failed to send transaction: ' + res.error.message);
    }

    assert__default['default'](typeof res.result !== 'undefined');
    assert__default['default'](res.result);
    return res.result;
  }
  /**
   * @private
   */


  _wsOnOpen() {
    this._rpcWebSocketConnected = true;
    this._rpcWebSocketHeartbeat = setInterval(() => {
      // Ping server every 5s to prevent idle timeouts
      this._rpcWebSocket.notify('ping').catch(() => {});
    }, 5000);

    this._updateSubscriptions();
  }
  /**
   * @private
   */


  _wsOnError(err) {
    console.error('ws error:', err.message);
  }
  /**
   * @private
   */


  _wsOnClose(code) {
    clearInterval(this._rpcWebSocketHeartbeat);
    this._rpcWebSocketHeartbeat = null;

    if (code === 1000) {
      // explicit close, check if any subscriptions have been made since close
      this._updateSubscriptions();

      return;
    } // implicit close, prepare subscriptions for auto-reconnect


    this._resetSubscriptions();
  }
  /**
   * @private
   */


  async _subscribe(sub, rpcMethod, rpcArgs) {
    if (sub.subscriptionId == null) {
      sub.subscriptionId = 'subscribing';

      try {
        const id = await this._rpcWebSocket.call(rpcMethod, rpcArgs);

        if (sub.subscriptionId === 'subscribing') {
          // eslint-disable-next-line require-atomic-updates
          sub.subscriptionId = id;
        }
      } catch (err) {
        if (sub.subscriptionId === 'subscribing') {
          // eslint-disable-next-line require-atomic-updates
          sub.subscriptionId = null;
        }

        console.error(`${rpcMethod} error for argument`, rpcArgs, err.message);
      }
    }
  }
  /**
   * @private
   */


  async _unsubscribe(sub, rpcMethod) {
    const subscriptionId = sub.subscriptionId;

    if (subscriptionId != null && typeof subscriptionId != 'string') {
      const unsubscribeId = subscriptionId;

      try {
        await this._rpcWebSocket.call(rpcMethod, [unsubscribeId]);
      } catch (err) {
        console.error(`${rpcMethod} error:`, err.message);
      }
    }
  }
  /**
   * @private
   */


  _resetSubscriptions() {
    Object.values(this._accountChangeSubscriptions).forEach(s => s.subscriptionId = null);
    Object.values(this._programAccountChangeSubscriptions).forEach(s => s.subscriptionId = null);
    Object.values(this._signatureSubscriptions).forEach(s => s.subscriptionId = null);
    Object.values(this._slotSubscriptions).forEach(s => s.subscriptionId = null);
    Object.values(this._rootSubscriptions).forEach(s => s.subscriptionId = null);
  }
  /**
   * @private
   */


  _updateSubscriptions() {
    const accountKeys = Object.keys(this._accountChangeSubscriptions).map(Number);
    const programKeys = Object.keys(this._programAccountChangeSubscriptions).map(Number);
    const slotKeys = Object.keys(this._slotSubscriptions).map(Number);
    const signatureKeys = Object.keys(this._signatureSubscriptions).map(Number);
    const rootKeys = Object.keys(this._rootSubscriptions).map(Number);

    if (accountKeys.length === 0 && programKeys.length === 0 && slotKeys.length === 0 && signatureKeys.length === 0 && rootKeys.length === 0) {
      if (this._rpcWebSocketConnected) {
        this._rpcWebSocketConnected = false;
        this._rpcWebSocketIdleTimeout = setTimeout(() => {
          this._rpcWebSocketIdleTimeout = null;

          this._rpcWebSocket.close();
        }, 500);
      }

      return;
    }

    if (this._rpcWebSocketIdleTimeout !== null) {
      clearTimeout(this._rpcWebSocketIdleTimeout);
      this._rpcWebSocketIdleTimeout = null;
      this._rpcWebSocketConnected = true;
    }

    if (!this._rpcWebSocketConnected) {
      this._rpcWebSocket.connect();

      return;
    }

    for (let id of accountKeys) {
      const sub = this._accountChangeSubscriptions[id];

      this._subscribe(sub, 'accountSubscribe', this._buildArgs([sub.publicKey], sub.commitment, 'base64'));
    }

    for (let id of programKeys) {
      const sub = this._programAccountChangeSubscriptions[id];

      this._subscribe(sub, 'programSubscribe', this._buildArgs([sub.programId], sub.commitment, 'base64'));
    }

    for (let id of slotKeys) {
      const sub = this._slotSubscriptions[id];

      this._subscribe(sub, 'slotSubscribe', []);
    }

    for (let id of signatureKeys) {
      const sub = this._signatureSubscriptions[id];

      this._subscribe(sub, 'signatureSubscribe', this._buildArgs([sub.signature], sub.commitment));
    }

    for (let id of rootKeys) {
      const sub = this._rootSubscriptions[id];

      this._subscribe(sub, 'rootSubscribe', []);
    }
  }
  /**
   * @private
   */


  _wsOnAccountNotification(notification) {
    const res = AccountNotificationResult(notification);

    if (res.error) {
      throw new Error('account notification failed: ' + res.error.message);
    }

    assert__default['default'](typeof res.result !== 'undefined');
    const keys = Object.keys(this._accountChangeSubscriptions).map(Number);

    for (let id of keys) {
      const sub = this._accountChangeSubscriptions[id];

      if (sub.subscriptionId === res.subscription) {
        const {
          result
        } = res;
        const {
          value,
          context
        } = result;
        assert__default['default'](value.data[1] === 'base64');
        sub.callback({
          executable: value.executable,
          owner: new PublicKey(value.owner),
          lamports: value.lamports,
          data: buffer.Buffer.from(value.data[0], 'base64')
        }, context);
        return true;
      }
    }
  }
  /**
   * Register a callback to be invoked whenever the specified account changes
   *
   * @param publicKey Public key of the account to monitor
   * @param callback Function to invoke whenever the account is changed
   * @param commitment Specify the commitment level account changes must reach before notification
   * @return subscription id
   */


  onAccountChange(publicKey, callback, commitment) {
    const id = ++this._accountChangeSubscriptionCounter;
    this._accountChangeSubscriptions[id] = {
      publicKey: publicKey.toBase58(),
      callback,
      commitment,
      subscriptionId: null
    };

    this._updateSubscriptions();

    return id;
  }
  /**
   * Deregister an account notification callback
   *
   * @param id subscription id to deregister
   */


  async removeAccountChangeListener(id) {
    if (this._accountChangeSubscriptions[id]) {
      const subInfo = this._accountChangeSubscriptions[id];
      delete this._accountChangeSubscriptions[id];
      await this._unsubscribe(subInfo, 'accountUnsubscribe');

      this._updateSubscriptions();
    } else {
      throw new Error(`Unknown account change id: ${id}`);
    }
  }
  /**
   * @private
   */


  _wsOnProgramAccountNotification(notification) {
    const res = ProgramAccountNotificationResult(notification);

    if (res.error) {
      throw new Error('program account notification failed: ' + res.error.message);
    }

    assert__default['default'](typeof res.result !== 'undefined');
    const keys = Object.keys(this._programAccountChangeSubscriptions).map(Number);

    for (let id of keys) {
      const sub = this._programAccountChangeSubscriptions[id];

      if (sub.subscriptionId === res.subscription) {
        const {
          result
        } = res;
        const {
          value,
          context
        } = result;
        assert__default['default'](value.account.data[1] === 'base64');
        sub.callback({
          accountId: value.pubkey,
          accountInfo: {
            executable: value.account.executable,
            owner: new PublicKey(value.account.owner),
            lamports: value.account.lamports,
            data: buffer.Buffer.from(value.account.data[0], 'base64')
          }
        }, context);
        return true;
      }
    }
  }
  /**
   * Register a callback to be invoked whenever accounts owned by the
   * specified program change
   *
   * @param programId Public key of the program to monitor
   * @param callback Function to invoke whenever the account is changed
   * @param commitment Specify the commitment level account changes must reach before notification
   * @return subscription id
   */


  onProgramAccountChange(programId, callback, commitment) {
    const id = ++this._programAccountChangeSubscriptionCounter;
    this._programAccountChangeSubscriptions[id] = {
      programId: programId.toBase58(),
      callback,
      commitment,
      subscriptionId: null
    };

    this._updateSubscriptions();

    return id;
  }
  /**
   * Deregister an account notification callback
   *
   * @param id subscription id to deregister
   */


  async removeProgramAccountChangeListener(id) {
    if (this._programAccountChangeSubscriptions[id]) {
      const subInfo = this._programAccountChangeSubscriptions[id];
      delete this._programAccountChangeSubscriptions[id];
      await this._unsubscribe(subInfo, 'programUnsubscribe');

      this._updateSubscriptions();
    } else {
      throw new Error(`Unknown program account change id: ${id}`);
    }
  }
  /**
   * @private
   */


  _wsOnSlotNotification(notification) {
    const res = SlotNotificationResult(notification);

    if (res.error) {
      throw new Error('slot notification failed: ' + res.error.message);
    }

    assert__default['default'](typeof res.result !== 'undefined');
    const {
      parent,
      slot,
      root
    } = res.result;
    const keys = Object.keys(this._slotSubscriptions).map(Number);

    for (let id of keys) {
      const sub = this._slotSubscriptions[id];

      if (sub.subscriptionId === res.subscription) {
        sub.callback({
          parent,
          slot,
          root
        });
        return true;
      }
    }
  }
  /**
   * Register a callback to be invoked upon slot changes
   *
   * @param callback Function to invoke whenever the slot changes
   * @return subscription id
   */


  onSlotChange(callback) {
    const id = ++this._slotSubscriptionCounter;
    this._slotSubscriptions[id] = {
      callback,
      subscriptionId: null
    };

    this._updateSubscriptions();

    return id;
  }
  /**
   * Deregister a slot notification callback
   *
   * @param id subscription id to deregister
   */


  async removeSlotChangeListener(id) {
    if (this._slotSubscriptions[id]) {
      const subInfo = this._slotSubscriptions[id];
      delete this._slotSubscriptions[id];
      await this._unsubscribe(subInfo, 'slotUnsubscribe');

      this._updateSubscriptions();
    } else {
      throw new Error(`Unknown slot change id: ${id}`);
    }
  }

  _buildArgs(args, override, encoding, extra) {
    const commitment = override || this._commitment;

    if (commitment || encoding || extra) {
      let options = {};

      if (encoding) {
        options.encoding = encoding;
      }

      if (commitment) {
        options.commitment = commitment;
      }

      if (extra) {
        options = Object.assign(options, extra);
      }

      args.push(options);
    }

    return args;
  }
  /**
   * @private
   */


  _wsOnSignatureNotification(notification) {
    const res = SignatureNotificationResult(notification);

    if (res.error) {
      throw new Error('signature notification failed: ' + res.error.message);
    }

    assert__default['default'](typeof res.result !== 'undefined');
    const keys = Object.keys(this._signatureSubscriptions).map(Number);

    for (let id of keys) {
      const sub = this._signatureSubscriptions[id];

      if (sub.subscriptionId === res.subscription) {
        // Signatures subscriptions are auto-removed by the RPC service so
        // no need to explicitly send an unsubscribe message
        delete this._signatureSubscriptions[id];

        this._updateSubscriptions();

        sub.callback(res.result.value, res.result.context);
        return;
      }
    }
  }
  /**
   * Register a callback to be invoked upon signature updates
   *
   * @param signature Transaction signature string in base 58
   * @param callback Function to invoke on signature notifications
   * @param commitment Specify the commitment level signature must reach before notification
   * @return subscription id
   */


  onSignature(signature, callback, commitment) {
    const id = ++this._signatureSubscriptionCounter;
    this._signatureSubscriptions[id] = {
      signature,
      callback,
      commitment,
      subscriptionId: null
    };

    this._updateSubscriptions();

    return id;
  }
  /**
   * Deregister a signature notification callback
   *
   * @param id subscription id to deregister
   */


  async removeSignatureListener(id) {
    if (this._signatureSubscriptions[id]) {
      const subInfo = this._signatureSubscriptions[id];
      delete this._signatureSubscriptions[id];
      await this._unsubscribe(subInfo, 'signatureUnsubscribe');

      this._updateSubscriptions();
    } else {
      throw new Error(`Unknown signature result id: ${id}`);
    }
  }
  /**
   * @private
   */


  _wsOnRootNotification(notification) {
    const res = RootNotificationResult(notification);

    if (res.error) {
      throw new Error('root notification failed: ' + res.error.message);
    }

    assert__default['default'](typeof res.result !== 'undefined');
    const root = res.result;
    const keys = Object.keys(this._rootSubscriptions).map(Number);

    for (let id of keys) {
      const sub = this._rootSubscriptions[id];

      if (sub.subscriptionId === res.subscription) {
        sub.callback(root);
        return true;
      }
    }
  }
  /**
   * Register a callback to be invoked upon root changes
   *
   * @param callback Function to invoke whenever the root changes
   * @return subscription id
   */


  onRootChange(callback) {
    const id = ++this._rootSubscriptionCounter;
    this._rootSubscriptions[id] = {
      callback,
      subscriptionId: null
    };

    this._updateSubscriptions();

    return id;
  }
  /**
   * Deregister a root notification callback
   *
   * @param id subscription id to deregister
   */


  async removeRootChangeListener(id) {
    if (this._rootSubscriptions[id]) {
      const subInfo = this._rootSubscriptions[id];
      delete this._rootSubscriptions[id];
      await this._unsubscribe(subInfo, 'rootUnsubscribe');

      this._updateSubscriptions();
    } else {
      throw new Error(`Unknown root change id: ${id}`);
    }
  }

}

//      
/**
 * Sign, send and confirm a transaction.
 *
 * If `commitment` option is not specified, defaults to 'max' commitment.
 *
 * @param {Connection} connection
 * @param {Transaction} transaction
 * @param {Array<Account>} signers
 * @param {ConfirmOptions} [options]
 * @returns {Promise<TransactionSignature>}
 */

async function sendAndConfirmTransaction(connection, transaction, signers, options) {
  const sendOptions = options && {
    skipPreflight: options.skipPreflight,
    preflightCommitment: options.preflightCommitment || options.commitment
  };
  const signature = await connection.sendTransaction(transaction, signers, sendOptions);
  const status = (await connection.confirmTransaction(signature, options && options.commitment)).value;

  if (status.err) {
    throw new Error(`Transaction ${signature} failed (${JSON.stringify(status)})`);
  }

  return signature;
}

//      
/**
 * @typedef {Object} InstructionType
 * @property (index} The Instruction index (from solana upstream program)
 * @property (BufferLayout} The BufferLayout to use to build data
 */

/**
 * Populate a buffer of instruction data using an InstructionType
 */

function encodeData(type, fields) {
  const allocLength = type.layout.span >= 0 ? type.layout.span : getAlloc(type, fields);
  const data = buffer.Buffer.alloc(allocLength);
  const layoutFields = Object.assign({
    instruction: type.index
  }, fields);
  type.layout.encode(layoutFields, data);
  return data;
}
/**
 * Decode instruction data buffer using an InstructionType
 */

function decodeData(type, buffer) {
  let data;

  try {
    data = type.layout.decode(buffer);
  } catch (err) {
    throw new Error('invalid instruction; ' + err);
  }

  if (data.instruction !== type.index) {
    throw new Error(`invalid instruction; instruction index mismatch ${data.instruction} != ${type.index}`);
  }

  return data;
}

//      
/**
 * Create account system transaction params
 * @typedef {Object} CreateAccountParams
 * @property {PublicKey} fromPubkey
 * @property {PublicKey} newAccountPubkey
 * @property {number} lamports
 * @property {number} space
 * @property {PublicKey} programId
 */

/**
 * Transfer system transaction params
 * @typedef {Object} TransferParams
 * @property {PublicKey} fromPubkey
 * @property {PublicKey} toPubkey
 * @property {number} lamports
 */

/**
 * Assign system transaction params
 * @typedef {Object} AssignParams
 * @property {PublicKey} accountPubkey
 * @property {PublicKey} programId
 */

/**
 * Create account with seed system transaction params
 * @typedef {Object} CreateAccountWithSeedParams
 * @property {PublicKey} fromPubkey
 * @property {PublicKey} newAccountPubkey
 * @property {PublicKey} basePubkey
 * @property {string} seed
 * @property {number} lamports
 * @property {number} space
 * @property {PublicKey} programId
 */

/**
 * Create nonce account system transaction params
 * @typedef {Object} CreateNonceAccountParams
 * @property {PublicKey} fromPubkey
 * @property {PublicKey} noncePubkey
 * @property {PublicKey} authorizedPubkey
 * @property {number} lamports
 */

/**
 * Create nonce account with seed system transaction params
 * @typedef {Object} CreateNonceAccountWithSeedParams
 * @property {PublicKey} fromPubkey
 * @property {PublicKey} noncePubkey
 * @property {PublicKey} authorizedPubkey
 * @property {PublicKey} basePubkey
 * @property {string} seed
 * @property {number} lamports
 */

/**
 * Initialize nonce account system instruction params
 * @typedef {Object} InitializeNonceParams
 * @property {PublicKey} noncePubkey
 * @property {PublicKey} authorizedPubkey
 */

/**
 * Advance nonce account system instruction params
 * @typedef {Object} AdvanceNonceParams
 * @property {PublicKey} noncePubkey
 * @property {PublicKey} authorizedPubkey
 */

/**
 * Withdraw nonce account system transaction params
 * @typedef {Object} WithdrawNonceParams
 * @property {PublicKey} noncePubkey
 * @property {PublicKey} authorizedPubkey
 * @property {PublicKey} toPubkey
 * @property {number} lamports
 */

/**
 * Authorize nonce account system transaction params
 * @typedef {Object} AuthorizeNonceParams
 * @property {PublicKey} noncePubkey
 * @property {PublicKey} authorizedPubkey
 * @property {PublicKey} newAuthorizedPubkey
 */

/**
 * Allocate account system transaction params
 * @typedef {Object} AllocateParams
 * @property {PublicKey} accountPubkey
 * @property {number} space
 */

/**
 * Allocate account with seed system transaction params
 * @typedef {Object} AllocateWithSeedParams
 * @property {PublicKey} accountPubkey
 * @property {PublicKey} basePubkey
 * @property {string} seed
 * @property {number} space
 * @property {PublicKey} programId
 */

/**
 * Assign account with seed system transaction params
 * @typedef {Object} AssignWithSeedParams
 * @property {PublicKey} accountPubkey
 * @property {PublicKey} basePubkey
 * @property {string} seed
 * @property {PublicKey} programId
 */

/**
 * Transfer with seed system transaction params
 * @typedef {Object} TransferWithSeedParams
 * @property {PublicKey} fromPubkey
 * @property {PublicKey} basePubkey
 * @property {PublicKey} toPubkey
 * @property {number} lamports
 * @property {string} seed
 * @property {PublicKey} programId
 */

/**
 * System Instruction class
 */

class SystemInstruction {
  /**
   * Decode a system instruction and retrieve the instruction type.
   */
  static decodeInstructionType(instruction) {
    this.checkProgramId(instruction.programId);
    const instructionTypeLayout = BufferLayout.u32('instruction');
    const typeIndex = instructionTypeLayout.decode(instruction.data);
    let type;

    for (const t of Object.keys(SYSTEM_INSTRUCTION_LAYOUTS)) {
      if (SYSTEM_INSTRUCTION_LAYOUTS[t].index == typeIndex) {
        type = t;
      }
    }

    if (!type) {
      throw new Error('Instruction type incorrect; not a SystemInstruction');
    }

    return type;
  }
  /**
   * Decode a create account system instruction and retrieve the instruction params.
   */


  static decodeCreateAccount(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 2);
    const {
      lamports,
      space,
      programId
    } = decodeData(SYSTEM_INSTRUCTION_LAYOUTS.Create, instruction.data);
    return {
      fromPubkey: instruction.keys[0].pubkey,
      newAccountPubkey: instruction.keys[1].pubkey,
      lamports,
      space,
      programId: new PublicKey(programId)
    };
  }
  /**
   * Decode a transfer system instruction and retrieve the instruction params.
   */


  static decodeTransfer(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 2);
    const {
      lamports
    } = decodeData(SYSTEM_INSTRUCTION_LAYOUTS.Transfer, instruction.data);
    return {
      fromPubkey: instruction.keys[0].pubkey,
      toPubkey: instruction.keys[1].pubkey,
      lamports
    };
  }
  /**
   * Decode a transfer with seed system instruction and retrieve the instruction params.
   */


  static decodeTransferWithSeed(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 3);
    const {
      lamports,
      seed,
      programId
    } = decodeData(SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed, instruction.data);
    return {
      fromPubkey: instruction.keys[0].pubkey,
      basePubkey: instruction.keys[1].pubkey,
      toPubkey: instruction.keys[2].pubkey,
      lamports,
      seed,
      programId: new PublicKey(programId)
    };
  }
  /**
   * Decode an allocate system instruction and retrieve the instruction params.
   */


  static decodeAllocate(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 1);
    const {
      space
    } = decodeData(SYSTEM_INSTRUCTION_LAYOUTS.Allocate, instruction.data);
    return {
      accountPubkey: instruction.keys[0].pubkey,
      space
    };
  }
  /**
   * Decode an allocate with seed system instruction and retrieve the instruction params.
   */


  static decodeAllocateWithSeed(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 1);
    const {
      base,
      seed,
      space,
      programId
    } = decodeData(SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed, instruction.data);
    return {
      accountPubkey: instruction.keys[0].pubkey,
      basePubkey: new PublicKey(base),
      seed,
      space,
      programId: new PublicKey(programId)
    };
  }
  /**
   * Decode an assign system instruction and retrieve the instruction params.
   */


  static decodeAssign(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 1);
    const {
      programId
    } = decodeData(SYSTEM_INSTRUCTION_LAYOUTS.Assign, instruction.data);
    return {
      accountPubkey: instruction.keys[0].pubkey,
      programId: new PublicKey(programId)
    };
  }
  /**
   * Decode an assign with seed system instruction and retrieve the instruction params.
   */


  static decodeAssignWithSeed(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 1);
    const {
      base,
      seed,
      programId
    } = decodeData(SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed, instruction.data);
    return {
      accountPubkey: instruction.keys[0].pubkey,
      basePubkey: new PublicKey(base),
      seed,
      programId: new PublicKey(programId)
    };
  }
  /**
   * Decode a create account with seed system instruction and retrieve the instruction params.
   */


  static decodeCreateWithSeed(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 2);
    const {
      base,
      seed,
      lamports,
      space,
      programId
    } = decodeData(SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed, instruction.data);
    return {
      fromPubkey: instruction.keys[0].pubkey,
      newAccountPubkey: instruction.keys[1].pubkey,
      basePubkey: new PublicKey(base),
      seed,
      lamports,
      space,
      programId: new PublicKey(programId)
    };
  }
  /**
   * Decode a nonce initialize system instruction and retrieve the instruction params.
   */


  static decodeNonceInitialize(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 3);
    const {
      authorized
    } = decodeData(SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount, instruction.data);
    return {
      noncePubkey: instruction.keys[0].pubkey,
      authorizedPubkey: new PublicKey(authorized)
    };
  }
  /**
   * Decode a nonce advance system instruction and retrieve the instruction params.
   */


  static decodeNonceAdvance(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 3);
    decodeData(SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount, instruction.data);
    return {
      noncePubkey: instruction.keys[0].pubkey,
      authorizedPubkey: instruction.keys[2].pubkey
    };
  }
  /**
   * Decode a nonce withdraw system instruction and retrieve the instruction params.
   */


  static decodeNonceWithdraw(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 5);
    const {
      lamports
    } = decodeData(SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount, instruction.data);
    return {
      noncePubkey: instruction.keys[0].pubkey,
      toPubkey: instruction.keys[1].pubkey,
      authorizedPubkey: instruction.keys[4].pubkey,
      lamports
    };
  }
  /**
   * Decode a nonce authorize system instruction and retrieve the instruction params.
   */


  static decodeNonceAuthorize(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 2);
    const {
      authorized
    } = decodeData(SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount, instruction.data);
    return {
      noncePubkey: instruction.keys[0].pubkey,
      authorizedPubkey: instruction.keys[1].pubkey,
      newAuthorizedPubkey: new PublicKey(authorized)
    };
  }
  /**
   * @private
   */


  static checkProgramId(programId) {
    if (!programId.equals(SystemProgram.programId)) {
      throw new Error('invalid instruction; programId is not SystemProgram');
    }
  }
  /**
   * @private
   */


  static checkKeyLength(keys, expectedLength) {
    if (keys.length < expectedLength) {
      throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
    }
  }

}
/**
 * An enumeration of valid SystemInstructionType's
 * @typedef {'Create' | 'Assign' | 'Transfer' | 'CreateWithSeed'
 | 'AdvanceNonceAccount' | 'WithdrawNonceAccount' | 'InitializeNonceAccount'
 | 'AuthorizeNonceAccount'} SystemInstructionType
 */

/**
 * An enumeration of valid system InstructionType's
 */

const SYSTEM_INSTRUCTION_LAYOUTS = Object.freeze({
  Create: {
    index: 0,
    layout: BufferLayout.struct([BufferLayout.u32('instruction'), BufferLayout.ns64('lamports'), BufferLayout.ns64('space'), publicKey('programId')])
  },
  Assign: {
    index: 1,
    layout: BufferLayout.struct([BufferLayout.u32('instruction'), publicKey('programId')])
  },
  Transfer: {
    index: 2,
    layout: BufferLayout.struct([BufferLayout.u32('instruction'), BufferLayout.ns64('lamports')])
  },
  CreateWithSeed: {
    index: 3,
    layout: BufferLayout.struct([BufferLayout.u32('instruction'), publicKey('base'), rustString('seed'), BufferLayout.ns64('lamports'), BufferLayout.ns64('space'), publicKey('programId')])
  },
  AdvanceNonceAccount: {
    index: 4,
    layout: BufferLayout.struct([BufferLayout.u32('instruction')])
  },
  WithdrawNonceAccount: {
    index: 5,
    layout: BufferLayout.struct([BufferLayout.u32('instruction'), BufferLayout.ns64('lamports')])
  },
  InitializeNonceAccount: {
    index: 6,
    layout: BufferLayout.struct([BufferLayout.u32('instruction'), publicKey('authorized')])
  },
  AuthorizeNonceAccount: {
    index: 7,
    layout: BufferLayout.struct([BufferLayout.u32('instruction'), publicKey('authorized')])
  },
  Allocate: {
    index: 8,
    layout: BufferLayout.struct([BufferLayout.u32('instruction'), BufferLayout.ns64('space')])
  },
  AllocateWithSeed: {
    index: 9,
    layout: BufferLayout.struct([BufferLayout.u32('instruction'), publicKey('base'), rustString('seed'), BufferLayout.ns64('space'), publicKey('programId')])
  },
  AssignWithSeed: {
    index: 10,
    layout: BufferLayout.struct([BufferLayout.u32('instruction'), publicKey('base'), rustString('seed'), publicKey('programId')])
  },
  TransferWithSeed: {
    index: 11,
    layout: BufferLayout.struct([BufferLayout.u32('instruction'), BufferLayout.ns64('lamports'), rustString('seed'), publicKey('programId')])
  }
});
/**
 * Factory class for transactions to interact with the System program
 */

class SystemProgram {
  /**
   * Public key that identifies the System program
   */
  static get programId() {
    return new PublicKey('11111111111111111111111111111111');
  }
  /**
   * Generate a transaction instruction that creates a new account
   */


  static createAccount(params) {
    const type = SYSTEM_INSTRUCTION_LAYOUTS.Create;
    const data = encodeData(type, {
      lamports: params.lamports,
      space: params.space,
      programId: params.programId.toBuffer()
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: params.fromPubkey,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: params.newAccountPubkey,
        isSigner: true,
        isWritable: true
      }],
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction instruction that transfers lamports from one account to another
   */


  static transfer(params) {
    let data;
    let keys;

    if (params.basePubkey) {
      const type = SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed;
      data = encodeData(type, {
        lamports: params.lamports,
        seed: params.seed,
        programId: params.programId.toBuffer()
      });
      keys = [{
        pubkey: params.fromPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      }, {
        pubkey: params.toPubkey,
        isSigner: false,
        isWritable: true
      }];
    } else {
      const type = SYSTEM_INSTRUCTION_LAYOUTS.Transfer;
      data = encodeData(type, {
        lamports: params.lamports
      });
      keys = [{
        pubkey: params.fromPubkey,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: params.toPubkey,
        isSigner: false,
        isWritable: true
      }];
    }

    return new TransactionInstruction({
      keys,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction instruction that assigns an account to a program
   */


  static assign(params) {
    let data;
    let keys;

    if (params.basePubkey) {
      const type = SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed;
      data = encodeData(type, {
        base: params.basePubkey.toBuffer(),
        seed: params.seed,
        programId: params.programId.toBuffer()
      });
      keys = [{
        pubkey: params.accountPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      }];
    } else {
      const type = SYSTEM_INSTRUCTION_LAYOUTS.Assign;
      data = encodeData(type, {
        programId: params.programId.toBuffer()
      });
      keys = [{
        pubkey: params.accountPubkey,
        isSigner: true,
        isWritable: true
      }];
    }

    return new TransactionInstruction({
      keys,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction instruction that creates a new account at
   *   an address generated with `from`, a seed, and programId
   */


  static createAccountWithSeed(params) {
    const type = SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed;
    const data = encodeData(type, {
      base: params.basePubkey.toBuffer(),
      seed: params.seed,
      lamports: params.lamports,
      space: params.space,
      programId: params.programId.toBuffer()
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: params.fromPubkey,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: params.newAccountPubkey,
        isSigner: false,
        isWritable: true
      }],
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction that creates a new Nonce account
   */


  static createNonceAccount(params) {
    const transaction = new Transaction();

    if (params.basePubkey && params.seed) {
      transaction.add(SystemProgram.createAccountWithSeed({
        fromPubkey: params.fromPubkey,
        newAccountPubkey: params.noncePubkey,
        basePubkey: params.basePubkey,
        seed: params.seed,
        lamports: params.lamports,
        space: NONCE_ACCOUNT_LENGTH,
        programId: this.programId
      }));
    } else {
      transaction.add(SystemProgram.createAccount({
        fromPubkey: params.fromPubkey,
        newAccountPubkey: params.noncePubkey,
        lamports: params.lamports,
        space: NONCE_ACCOUNT_LENGTH,
        programId: this.programId
      }));
    }

    const initParams = {
      noncePubkey: params.noncePubkey,
      authorizedPubkey: params.authorizedPubkey
    };
    transaction.add(this.nonceInitialize(initParams));
    return transaction;
  }
  /**
   * Generate an instruction to initialize a Nonce account
   */


  static nonceInitialize(params) {
    const type = SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount;
    const data = encodeData(type, {
      authorized: params.authorizedPubkey.toBuffer()
    });
    const instructionData = {
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: false,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction(instructionData);
  }
  /**
   * Generate an instruction to advance the nonce in a Nonce account
   */


  static nonceAdvance(params) {
    const type = SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount;
    const data = encodeData(type);
    const instructionData = {
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: params.authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction(instructionData);
  }
  /**
   * Generate a transaction instruction that withdraws lamports from a Nonce account
   */


  static nonceWithdraw(params) {
    const type = SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount;
    const data = encodeData(type, {
      lamports: params.lamports
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.toPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: params.authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction instruction that authorizes a new PublicKey as the authority
   * on a Nonce account.
   */


  static nonceAuthorize(params) {
    const type = SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount;
    const data = encodeData(type, {
      authorized: params.newAuthorizedPubkey.toBuffer()
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction instruction that allocates space in an account without funding
   */


  static allocate(params) {
    let data;
    let keys;

    if (params.basePubkey) {
      const type = SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed;
      data = encodeData(type, {
        base: params.basePubkey.toBuffer(),
        seed: params.seed,
        space: params.space,
        programId: params.programId.toBuffer()
      });
      keys = [{
        pubkey: params.accountPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      }];
    } else {
      const type = SYSTEM_INSTRUCTION_LAYOUTS.Allocate;
      data = encodeData(type, {
        space: params.space
      });
      keys = [{
        pubkey: params.accountPubkey,
        isSigner: true,
        isWritable: true
      }];
    }

    return new TransactionInstruction({
      keys,
      programId: this.programId,
      data
    });
  }

}

//      
/**
 * Program loader interface
 */

class Loader {
  /**
   * Amount of program data placed in each load Transaction
   */
  static get chunkSize() {
    // Keep program chunks under PACKET_DATA_SIZE, leaving enough room for the
    // rest of the Transaction fields
    //
    // TODO: replace 300 with a proper constant for the size of the other
    // Transaction fields
    return PACKET_DATA_SIZE - 300;
  }
  /**
   * Minimum number of signatures required to load a program not including
   * retries
   *
   * Can be used to calculate transaction fees
   */


  static getMinNumSignatures(dataLength) {
    return 2 * ( // Every transaction requires two signatures (payer + program)
    Math.ceil(dataLength / Loader.chunkSize) + 1 + // Add one for Create transaction
    1) // Add one for Finalize transaction
    ;
  }
  /**
   * Loads a generic program
   *
   * @param connection The connection to use
   * @param payer System account that pays to load the program
   * @param program Account to load the program into
   * @param programId Public key that identifies the loader
   * @param data Program octets
   * @return true if program was loaded successfully, false if program was already loaded
   */


  static async load(connection, payer, program, programId, data) {
    {
      const balanceNeeded = await connection.getMinimumBalanceForRentExemption(data.length); // Fetch program account info to check if it has already been created

      const programInfo = await connection.getAccountInfo(program.publicKey, 'singleGossip');
      let transaction = null;

      if (programInfo !== null) {
        if (programInfo.executable) {
          console.error('Program load failed, account is already executable');
          return false;
        }

        if (programInfo.data.length !== data.length) {
          transaction = transaction || new Transaction();
          transaction.add(SystemProgram.allocate({
            accountPubkey: program.publicKey,
            space: data.length
          }));
        }

        if (!programInfo.owner.equals(programId)) {
          transaction = transaction || new Transaction();
          transaction.add(SystemProgram.assign({
            accountPubkey: program.publicKey,
            programId
          }));
        }

        if (programInfo.lamports < balanceNeeded) {
          transaction = transaction || new Transaction();
          transaction.add(SystemProgram.transfer({
            fromPubkey: payer.publicKey,
            toPubkey: program.publicKey,
            lamports: balanceNeeded - programInfo.lamports
          }));
        }
      } else {
        transaction = new Transaction().add(SystemProgram.createAccount({
          fromPubkey: payer.publicKey,
          newAccountPubkey: program.publicKey,
          lamports: balanceNeeded > 0 ? balanceNeeded : 1,
          space: data.length,
          programId
        }));
      } // If the account is already created correctly, skip this step
      // and proceed directly to loading instructions


      if (transaction !== null) {
        await sendAndConfirmTransaction(connection, transaction, [payer, program], {
          commitment: 'singleGossip'
        });
      }
    }
    const dataLayout = BufferLayout.struct([BufferLayout.u32('instruction'), BufferLayout.u32('offset'), BufferLayout.u32('bytesLength'), BufferLayout.u32('bytesLengthPadding'), BufferLayout.seq(BufferLayout.u8('byte'), BufferLayout.offset(BufferLayout.u32(), -8), 'bytes')]);
    const chunkSize = Loader.chunkSize;
    let offset = 0;
    let array = data;
    let transactions = [];

    while (array.length > 0) {
      const bytes = array.slice(0, chunkSize);
      const data = buffer.Buffer.alloc(chunkSize + 16);
      dataLayout.encode({
        instruction: 0,
        // Load instruction
        offset,
        bytes
      }, data);
      const transaction = new Transaction().add({
        keys: [{
          pubkey: program.publicKey,
          isSigner: true,
          isWritable: true
        }],
        programId,
        data
      });
      transactions.push(sendAndConfirmTransaction(connection, transaction, [payer, program], {
        commitment: 'singleGossip'
      })); // Delay between sends in an attempt to reduce rate limit errors

      if (connection._rpcEndpoint.includes('solana.com')) {
        const REQUESTS_PER_SECOND = 4;
        await sleep(1000 / REQUESTS_PER_SECOND);
      }

      offset += chunkSize;
      array = array.slice(chunkSize);
    }

    await Promise.all(transactions); // Finalize the account loaded with program data for execution

    {
      const dataLayout = BufferLayout.struct([BufferLayout.u32('instruction')]);
      const data = buffer.Buffer.alloc(dataLayout.span);
      dataLayout.encode({
        instruction: 1 // Finalize instruction

      }, data);
      const transaction = new Transaction().add({
        keys: [{
          pubkey: program.publicKey,
          isSigner: true,
          isWritable: true
        }, {
          pubkey: SYSVAR_RENT_PUBKEY,
          isSigner: false,
          isWritable: false
        }],
        programId,
        data
      });
      await sendAndConfirmTransaction(connection, transaction, [payer, program], {
        commitment: 'singleGossip'
      });
    } // success

    return true;
  }

}

//      
const BPF_LOADER_PROGRAM_ID = new PublicKey('BPFLoader2111111111111111111111111111111111');
/**
 * Factory class for transactions to interact with a program loader
 */

class BpfLoader {
  /**
   * Minimum number of signatures required to load a program not including
   * retries
   *
   * Can be used to calculate transaction fees
   */
  static getMinNumSignatures(dataLength) {
    return Loader.getMinNumSignatures(dataLength);
  }
  /**
   * Load a BPF program
   *
   * @param connection The connection to use
   * @param payer Account that will pay program loading fees
   * @param program Account to load the program into
   * @param elf The entire ELF containing the BPF program
   * @param loaderProgramId The program id of the BPF loader to use
   * @return true if program was loaded successfully, false if program was already loaded
   */


  static load(connection, payer, program, elf, loaderProgramId) {
    return Loader.load(connection, payer, program, loaderProgramId, elf);
  }

}

const STAKE_CONFIG_ID = new PublicKey('StakeConfig11111111111111111111111111111111');
class Authorized {
  /**
   * Create a new Authorized object
   */
  constructor(staker, withdrawer) {
    _defineProperty__default['default'](this, "staker", void 0);

    _defineProperty__default['default'](this, "withdrawer", void 0);

    this.staker = staker;
    this.withdrawer = withdrawer;
  }

}
class Lockup {
  /**
   * Create a new Lockup object
   */
  constructor(unixTimestamp, epoch, custodian) {
    _defineProperty__default['default'](this, "unixTimestamp", void 0);

    _defineProperty__default['default'](this, "epoch", void 0);

    _defineProperty__default['default'](this, "custodian", void 0);

    this.unixTimestamp = unixTimestamp;
    this.epoch = epoch;
    this.custodian = custodian;
  }

}
/**
 * Create stake account transaction params
 * @typedef {Object} CreateStakeAccountParams
 * @property {PublicKey} fromPubkey
 * @property {PublicKey} stakePubkey
 * @property {Authorized} authorized
 * @property {Lockup} lockup
 * @property {number} lamports
 */

/**
 * Create stake account with seed transaction params
 * @typedef {Object} CreateStakeAccountWithSeedParams
 * @property {PublicKey} fromPubkey
 * @property {PublicKey} stakePubkey
 * @property {PublicKey} basePubkey
 * @property {string} seed
 * @property {Authorized} authorized
 * @property {Lockup} lockup
 * @property {number} lamports
 */

/**
 * Initialize stake instruction params
 * @typedef {Object} InitializeStakeParams
 * @property {PublicKey} stakePubkey
 * @property {Authorized} authorized
 * @property {Lockup} lockup
 */

/**
 * Delegate stake instruction params
 * @typedef {Object} DelegateStakeParams
 * @property {PublicKey} stakePubkey
 * @property {PublicKey} authorizedPubkey
 * @property {PublicKey} votePubkey
 */

/**
 * Authorize stake instruction params
 * @typedef {Object} AuthorizeStakeParams
 * @property {PublicKey} stakePubkey
 * @property {PublicKey} authorizedPubkey
 * @property {PublicKey} newAuthorizedPubkey
 * @property {StakeAuthorizationType} stakeAuthorizationType
 * @property {PublicKey} custodianPubkey
 */

/**
 * Authorize stake instruction params using a derived key
 * @typedef {Object} AuthorizeWithSeedStakeParams
 * @property {PublicKey} stakePubkey
 * @property {PublicKey} authorityBase
 * @property {string} authoritySeed
 * @property {PublicKey} authorityOwner
 * @property {PublicKey} newAuthorizedPubkey
 * @property {StakeAuthorizationType} stakeAuthorizationType
 * @property {PublicKey} custodianPubkey
 */

/**
 * Split stake instruction params
 * @typedef {Object} SplitStakeParams
 * @property {PublicKey} stakePubkey
 * @property {PublicKey} authorizedPubkey
 * @property {PublicKey} splitStakePubkey
 * @property {number} lamports
 */

/**
 * Withdraw stake instruction params
 * @typedef {Object} WithdrawStakeParams
 * @property {PublicKey} stakePubkey
 * @property {PublicKey} authorizedPubkey
 * @property {PublicKey} toPubkey
 * @property {number} lamports
 * @property {PublicKey} custodianPubkey
 */

/**
 * Deactivate stake instruction params
 * @typedef {Object} DeactivateStakeParams
 * @property {PublicKey} stakePubkey
 * @property {PublicKey} authorizedPubkey
 */

/**
 * Stake Instruction class
 */

class StakeInstruction {
  /**
   * Decode a stake instruction and retrieve the instruction type.
   */
  static decodeInstructionType(instruction) {
    this.checkProgramId(instruction.programId);
    const instructionTypeLayout = BufferLayout.u32('instruction');
    const typeIndex = instructionTypeLayout.decode(instruction.data);
    let type;

    for (const t of Object.keys(STAKE_INSTRUCTION_LAYOUTS)) {
      if (STAKE_INSTRUCTION_LAYOUTS[t].index == typeIndex) {
        type = t;
      }
    }

    if (!type) {
      throw new Error('Instruction type incorrect; not a StakeInstruction');
    }

    return type;
  }
  /**
   * Decode a initialize stake instruction and retrieve the instruction params.
   */


  static decodeInitialize(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 2);
    const {
      authorized,
      lockup
    } = decodeData(STAKE_INSTRUCTION_LAYOUTS.Initialize, instruction.data);
    return {
      stakePubkey: instruction.keys[0].pubkey,
      authorized: new Authorized(new PublicKey(authorized.staker), new PublicKey(authorized.withdrawer)),
      lockup: new Lockup(lockup.unixTimestamp, lockup.epoch, new PublicKey(lockup.custodian))
    };
  }
  /**
   * Decode a delegate stake instruction and retrieve the instruction params.
   */


  static decodeDelegate(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 6);
    decodeData(STAKE_INSTRUCTION_LAYOUTS.Delegate, instruction.data);
    return {
      stakePubkey: instruction.keys[0].pubkey,
      votePubkey: instruction.keys[1].pubkey,
      authorizedPubkey: instruction.keys[5].pubkey
    };
  }
  /**
   * Decode an authorize stake instruction and retrieve the instruction params.
   */


  static decodeAuthorize(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 3);
    const {
      newAuthorized,
      stakeAuthorizationType
    } = decodeData(STAKE_INSTRUCTION_LAYOUTS.Authorize, instruction.data);
    const o = {
      stakePubkey: instruction.keys[0].pubkey,
      authorizedPubkey: instruction.keys[2].pubkey,
      newAuthorizedPubkey: new PublicKey(newAuthorized),
      stakeAuthorizationType: {
        index: stakeAuthorizationType
      }
    };

    if (instruction.keys.length > 3) {
      o.custodianPubkey = instruction.keys[3].pubkey;
    }

    return o;
  }
  /**
   * Decode an authorize-with-seed stake instruction and retrieve the instruction params.
   */


  static decodeAuthorizeWithSeed(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 2);
    const {
      newAuthorized,
      stakeAuthorizationType,
      authoritySeed,
      authorityOwner
    } = decodeData(STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data);
    const o = {
      stakePubkey: instruction.keys[0].pubkey,
      authorityBase: instruction.keys[1].pubkey,
      authoritySeed: authoritySeed,
      authorityOwner: new PublicKey(authorityOwner),
      newAuthorizedPubkey: new PublicKey(newAuthorized),
      stakeAuthorizationType: {
        index: stakeAuthorizationType
      }
    };

    if (instruction.keys.length > 3) {
      o.custodianPubkey = instruction.keys[3].pubkey;
    }

    return o;
  }
  /**
   * Decode a split stake instruction and retrieve the instruction params.
   */


  static decodeSplit(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 3);
    const {
      lamports
    } = decodeData(STAKE_INSTRUCTION_LAYOUTS.Split, instruction.data);
    return {
      stakePubkey: instruction.keys[0].pubkey,
      splitStakePubkey: instruction.keys[1].pubkey,
      authorizedPubkey: instruction.keys[2].pubkey,
      lamports
    };
  }
  /**
   * Decode a withdraw stake instruction and retrieve the instruction params.
   */


  static decodeWithdraw(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 5);
    const {
      lamports
    } = decodeData(STAKE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data);
    const o = {
      stakePubkey: instruction.keys[0].pubkey,
      toPubkey: instruction.keys[1].pubkey,
      authorizedPubkey: instruction.keys[4].pubkey,
      lamports
    };

    if (instruction.keys.length > 5) {
      o.custodianPubkey = instruction.keys[5].pubkey;
    }

    return o;
  }
  /**
   * Decode a deactivate stake instruction and retrieve the instruction params.
   */


  static decodeDeactivate(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 3);
    decodeData(STAKE_INSTRUCTION_LAYOUTS.Deactivate, instruction.data);
    return {
      stakePubkey: instruction.keys[0].pubkey,
      authorizedPubkey: instruction.keys[2].pubkey
    };
  }
  /**
   * @private
   */


  static checkProgramId(programId) {
    if (!programId.equals(StakeProgram.programId)) {
      throw new Error('invalid instruction; programId is not StakeProgram');
    }
  }
  /**
   * @private
   */


  static checkKeyLength(keys, expectedLength) {
    if (keys.length < expectedLength) {
      throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
    }
  }

}
/**
 * An enumeration of valid StakeInstructionType's
 * @typedef { 'Initialize' | 'Authorize' | 'AuthorizeWithSeed' | 'Delegate' | 'Split' | 'Withdraw'
 | 'Deactivate' } StakeInstructionType
 */

/**
 * An enumeration of valid stake InstructionType's
 */

const STAKE_INSTRUCTION_LAYOUTS = Object.freeze({
  Initialize: {
    index: 0,
    layout: BufferLayout.struct([BufferLayout.u32('instruction'), authorized(), lockup()])
  },
  Authorize: {
    index: 1,
    layout: BufferLayout.struct([BufferLayout.u32('instruction'), publicKey('newAuthorized'), BufferLayout.u32('stakeAuthorizationType')])
  },
  Delegate: {
    index: 2,
    layout: BufferLayout.struct([BufferLayout.u32('instruction')])
  },
  Split: {
    index: 3,
    layout: BufferLayout.struct([BufferLayout.u32('instruction'), BufferLayout.ns64('lamports')])
  },
  Withdraw: {
    index: 4,
    layout: BufferLayout.struct([BufferLayout.u32('instruction'), BufferLayout.ns64('lamports')])
  },
  Deactivate: {
    index: 5,
    layout: BufferLayout.struct([BufferLayout.u32('instruction')])
  },
  AuthorizeWithSeed: {
    index: 8,
    layout: BufferLayout.struct([BufferLayout.u32('instruction'), publicKey('newAuthorized'), BufferLayout.u32('stakeAuthorizationType'), rustString('authoritySeed'), publicKey('authorityOwner')])
  }
});
/**
 * @typedef {Object} StakeAuthorizationType
 * @property (index} The Stake Authorization index (from solana-stake-program)
 */

/**
 * An enumeration of valid StakeAuthorizationLayout's
 */

const StakeAuthorizationLayout = Object.freeze({
  Staker: {
    index: 0
  },
  Withdrawer: {
    index: 1
  }
});
/**
 * Factory class for transactions to interact with the Stake program
 */

class StakeProgram {
  /**
   * Public key that identifies the Stake program
   */
  static get programId() {
    return new PublicKey('Stake11111111111111111111111111111111111111');
  }
  /**
   * Max space of a Stake account
   *
   * This is generated from the solana-stake-program StakeState struct as
   * `std::mem::size_of::<StakeState>()`:
   * https://docs.rs/solana-stake-program/1.4.4/solana_stake_program/stake_state/enum.StakeState.html
   */


  static get space() {
    return 200;
  }
  /**
   * Generate an Initialize instruction to add to a Stake Create transaction
   */


  static initialize(params) {
    const {
      stakePubkey,
      authorized,
      lockup
    } = params;
    const type = STAKE_INSTRUCTION_LAYOUTS.Initialize;
    const data = encodeData(type, {
      authorized: {
        staker: authorized.staker.toBuffer(),
        withdrawer: authorized.withdrawer.toBuffer()
      },
      lockup: {
        unixTimestamp: lockup.unixTimestamp,
        epoch: lockup.epoch,
        custodian: lockup.custodian.toBuffer()
      }
    });
    const instructionData = {
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: false,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction(instructionData);
  }
  /**
   * Generate a Transaction that creates a new Stake account at
   *   an address generated with `from`, a seed, and the Stake programId
   */


  static createAccountWithSeed(params) {
    const transaction = new Transaction();
    transaction.add(SystemProgram.createAccountWithSeed({
      fromPubkey: params.fromPubkey,
      newAccountPubkey: params.stakePubkey,
      basePubkey: params.basePubkey,
      seed: params.seed,
      lamports: params.lamports,
      space: this.space,
      programId: this.programId
    }));
    const {
      stakePubkey,
      authorized,
      lockup
    } = params;
    return transaction.add(this.initialize({
      stakePubkey,
      authorized,
      lockup
    }));
  }
  /**
   * Generate a Transaction that creates a new Stake account
   */


  static createAccount(params) {
    const transaction = new Transaction();
    transaction.add(SystemProgram.createAccount({
      fromPubkey: params.fromPubkey,
      newAccountPubkey: params.stakePubkey,
      lamports: params.lamports,
      space: this.space,
      programId: this.programId
    }));
    const {
      stakePubkey,
      authorized,
      lockup
    } = params;
    return transaction.add(this.initialize({
      stakePubkey,
      authorized,
      lockup
    }));
  }
  /**
   * Generate a Transaction that delegates Stake tokens to a validator
   * Vote PublicKey. This transaction can also be used to redelegate Stake
   * to a new validator Vote PublicKey.
   */


  static delegate(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      votePubkey
    } = params;
    const type = STAKE_INSTRUCTION_LAYOUTS.Delegate;
    const data = encodeData(type);
    return new Transaction().add({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: votePubkey,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: STAKE_CONFIG_ID,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a Transaction that authorizes a new PublicKey as Staker
   * or Withdrawer on the Stake account.
   */


  static authorize(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      newAuthorizedPubkey,
      stakeAuthorizationType,
      custodianPubkey
    } = params;
    const type = STAKE_INSTRUCTION_LAYOUTS.Authorize;
    const data = encodeData(type, {
      newAuthorized: newAuthorizedPubkey.toBuffer(),
      stakeAuthorizationType: stakeAuthorizationType.index
    });
    const keys = [{
      pubkey: stakePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: authorizedPubkey,
      isSigner: true,
      isWritable: false
    }];

    if (custodianPubkey) {
      keys.push({
        pubkey: custodianPubkey,
        isSigner: false,
        isWritable: false
      });
    }

    return new Transaction().add({
      keys,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a Transaction that authorizes a new PublicKey as Staker
   * or Withdrawer on the Stake account.
   */


  static authorizeWithSeed(params) {
    const {
      stakePubkey,
      authorityBase,
      authoritySeed,
      authorityOwner,
      newAuthorizedPubkey,
      stakeAuthorizationType,
      custodianPubkey
    } = params;
    const type = STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;
    const data = encodeData(type, {
      newAuthorized: newAuthorizedPubkey.toBuffer(),
      stakeAuthorizationType: stakeAuthorizationType.index,
      authoritySeed: authoritySeed,
      authorityOwner: authorityOwner.toBuffer()
    });
    const keys = [{
      pubkey: stakePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: authorityBase,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: false,
      isWritable: false
    }];

    if (custodianPubkey) {
      keys.push({
        pubkey: custodianPubkey,
        isSigner: false,
        isWritable: false
      });
    }

    return new Transaction().add({
      keys,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a Transaction that splits Stake tokens into another stake account
   */


  static split(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      splitStakePubkey,
      lamports
    } = params;
    const transaction = new Transaction();
    transaction.add(SystemProgram.createAccount({
      fromPubkey: authorizedPubkey,
      newAccountPubkey: splitStakePubkey,
      lamports: 0,
      space: this.space,
      programId: this.programId
    }));
    const type = STAKE_INSTRUCTION_LAYOUTS.Split;
    const data = encodeData(type, {
      lamports
    });
    return transaction.add({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: splitStakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a Transaction that withdraws deactivated Stake tokens.
   */


  static withdraw(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      toPubkey,
      lamports,
      custodianPubkey
    } = params;
    const type = STAKE_INSTRUCTION_LAYOUTS.Withdraw;
    const data = encodeData(type, {
      lamports
    });
    const keys = [{
      pubkey: stakePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: toPubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: authorizedPubkey,
      isSigner: true,
      isWritable: false
    }];

    if (custodianPubkey) {
      keys.push({
        pubkey: custodianPubkey,
        isSigner: false,
        isWritable: false
      });
    }

    return new Transaction().add({
      keys,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a Transaction that deactivates Stake tokens.
   */


  static deactivate(params) {
    const {
      stakePubkey,
      authorizedPubkey
    } = params;
    const type = STAKE_INSTRUCTION_LAYOUTS.Deactivate;
    const data = encodeData(type);
    return new Transaction().add({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }

}

//      
const {
  publicKeyCreate,
  ecdsaSign
} = secp256k1__default['default'];
const PRIVATE_KEY_BYTES = 32;
const PUBLIC_KEY_BYTES = 65;
const HASHED_PUBKEY_SERIALIZED_SIZE = 20;
const SIGNATURE_OFFSETS_SERIALIZED_SIZE = 11;
/**
 * Create a Secp256k1 instruction using a public key params
 * @typedef {Object} CreateSecp256k1InstructionWithPublicKeyParams
 * @property {Buffer | Uint8Array | Array<number>} publicKey
 * @property {Buffer | Uint8Array | Array<number>} message
 * @property {Buffer | Uint8Array | Array<number>} signature
 * @property {number} recoveryId
 */

/**
 * Create a Secp256k1 instruction using a private key params
 * @typedef {Object} CreateSecp256k1InstructionWithPrivateKeyParams
 * @property {Buffer | Uint8Array | Array<number>} privateKey
 * @property {Buffer | Uint8Array | Array<number>} message
 */

const SECP256K1_INSTRUCTION_LAYOUT = BufferLayout.struct([BufferLayout.u8('numSignatures'), BufferLayout.u16('signatureOffset'), BufferLayout.u8('signatureInstructionIndex'), BufferLayout.u16('ethAddressOffset'), BufferLayout.u8('ethAddressInstructionIndex'), BufferLayout.u16('messageDataOffset'), BufferLayout.u16('messageDataSize'), BufferLayout.u8('messageInstructionIndex'), BufferLayout.blob(20, 'ethPublicKey'), BufferLayout.blob(64, 'signature'), BufferLayout.u8('recoveryId')]);
class Secp256k1Program {
  /**
   * Public key that identifies the Secp256k program
   */
  static get programId() {
    return new PublicKey('KeccakSecp256k11111111111111111111111111111');
  }
  /**
   * Create a secp256k1 instruction with public key
   */


  static createInstructionWithPublicKey(params) {
    const {
      publicKey,
      message,
      signature,
      recoveryId
    } = params;
    assert__default['default'](publicKey.length === PUBLIC_KEY_BYTES, `Public key must be ${PUBLIC_KEY_BYTES} bytes`);
    let ethPublicKey;

    try {
      ethPublicKey = constructEthPubkey(publicKey);
    } catch (error) {
      throw new Error(`Error constructing ethereum public key: ${error}`);
    }

    const dataStart = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE;
    const ethAddressOffset = dataStart;
    const signatureOffset = dataStart + ethPublicKey.length;
    const messageDataOffset = signatureOffset + signature.length + 1;
    const numSignatures = 1;
    const instructionData = buffer.Buffer.alloc(SECP256K1_INSTRUCTION_LAYOUT.span + message.length);
    SECP256K1_INSTRUCTION_LAYOUT.encode({
      numSignatures: numSignatures,
      signatureOffset: signatureOffset,
      signatureInstructionIndex: 0,
      ethAddressOffset: ethAddressOffset,
      ethAddressInstructionIndex: 0,
      messageDataOffset: messageDataOffset,
      messageDataSize: message.length,
      messageInstructionIndex: 0,
      signature: toBuffer(signature),
      ethPublicKey: ethPublicKey,
      recoveryId: recoveryId
    }, instructionData);
    instructionData.fill(toBuffer(message), SECP256K1_INSTRUCTION_LAYOUT.span);
    return new TransactionInstruction({
      keys: [],
      programId: Secp256k1Program.programId,
      data: instructionData
    });
  }
  /**
   * Create a secp256k1 instruction with private key
   */


  static createInstructionWithPrivateKey(params) {
    const {
      privateKey,
      message
    } = params;
    assert__default['default'](privateKey.length === PRIVATE_KEY_BYTES, `Private key must be ${PRIVATE_KEY_BYTES} bytes`);

    try {
      const publicKey = publicKeyCreate(privateKey, false);
      const messageHash = buffer.Buffer.from(jsSha3.keccak_256.update(toBuffer(message)).digest());
      const {
        signature,
        recid: recoveryId
      } = ecdsaSign(messageHash, privateKey);
      return this.createInstructionWithPublicKey({
        publicKey,
        message,
        signature,
        recoveryId
      });
    } catch (error) {
      throw new Error(`Error creating instruction; ${error}`);
    }
  }

}

function constructEthPubkey(publicKey) {
  return buffer.Buffer.from(jsSha3.keccak_256.update(toBuffer(publicKey.slice(1))) // throw away leading byte
  .digest()).slice(-HASHED_PUBKEY_SERIALIZED_SIZE);
}

const VALIDATOR_INFO_KEY = new PublicKey('Va1idator1nfo111111111111111111111111111111');
/**
 * @private
 */

/**
 * Info used to identity validators.
 *
 * @typedef {Object} Info
 * @property {string} name validator name
 * @property {?string} website optional, validator website
 * @property {?string} details optional, extra information the validator chose to share
 * @property {?string} keybaseUsername optional, used to identify validators on keybase.io
 */

const InfoString = superstruct.struct({
  name: 'string',
  website: 'string?',
  details: 'string?',
  keybaseUsername: 'string?'
});
/**
 * ValidatorInfo class
 */

class ValidatorInfo {
  /**
   * validator public key
   */

  /**
   * validator information
   */

  /**
   * Construct a valid ValidatorInfo
   *
   * @param key validator public key
   * @param info validator information
   */
  constructor(key, info) {
    _defineProperty__default['default'](this, "key", void 0);

    _defineProperty__default['default'](this, "info", void 0);

    this.key = key;
    this.info = info;
  }
  /**
   * Deserialize ValidatorInfo from the config account data. Exactly two config
   * keys are required in the data.
   *
   * @param buffer config account data
   * @return null if info was not found
   */


  static fromConfigData(buffer$1) {
    const PUBKEY_LENGTH = 32;
    let byteArray = [...buffer$1];
    const configKeyCount = decodeLength(byteArray);
    if (configKeyCount !== 2) return null;
    const configKeys = [];

    for (let i = 0; i < 2; i++) {
      const publicKey = new PublicKey(byteArray.slice(0, PUBKEY_LENGTH));
      byteArray = byteArray.slice(PUBKEY_LENGTH);
      const isSigner = byteArray.slice(0, 1)[0] === 1;
      byteArray = byteArray.slice(1);
      configKeys.push({
        publicKey,
        isSigner
      });
    }

    if (configKeys[0].publicKey.equals(VALIDATOR_INFO_KEY)) {
      if (configKeys[1].isSigner) {
        const rawInfo = rustString().decode(buffer.Buffer.from(byteArray));
        const info = InfoString(JSON.parse(rawInfo));
        return new ValidatorInfo(configKeys[1].publicKey, info);
      }
    }

    return null;
  }

}

const VOTE_PROGRAM_ID = new PublicKey('Vote111111111111111111111111111111111111111');
/**
 * History of how many credits earned by the end of each epoch
 */

/**
 * See https://github.com/solana-labs/solana/blob/8a12ed029cfa38d4a45400916c2463fb82bbec8c/programs/vote_api/src/vote_state.rs#L68-L88
 *
 * @private
 */

const VoteAccountLayout = BufferLayout.struct([publicKey('nodePubkey'), publicKey('authorizedVoterPubkey'), publicKey('authorizedWithdrawerPubkey'), BufferLayout.u8('commission'), BufferLayout.nu64(), // votes.length
BufferLayout.seq(BufferLayout.struct([BufferLayout.nu64('slot'), BufferLayout.u32('confirmationCount')]), BufferLayout.offset(BufferLayout.u32(), -8), 'votes'), BufferLayout.u8('rootSlotValid'), BufferLayout.nu64('rootSlot'), BufferLayout.nu64('epoch'), BufferLayout.nu64('credits'), BufferLayout.nu64('lastEpochCredits'), BufferLayout.nu64(), // epochCredits.length
BufferLayout.seq(BufferLayout.struct([BufferLayout.nu64('epoch'), BufferLayout.nu64('credits'), BufferLayout.nu64('prevCredits')]), BufferLayout.offset(BufferLayout.u32(), -8), 'epochCredits')]);
/**
 * VoteAccount class
 */

class VoteAccount {
  constructor() {
    _defineProperty__default['default'](this, "nodePubkey", void 0);

    _defineProperty__default['default'](this, "authorizedVoterPubkey", void 0);

    _defineProperty__default['default'](this, "authorizedWithdrawerPubkey", void 0);

    _defineProperty__default['default'](this, "commission", void 0);

    _defineProperty__default['default'](this, "votes", void 0);

    _defineProperty__default['default'](this, "rootSlot", void 0);

    _defineProperty__default['default'](this, "epoch", void 0);

    _defineProperty__default['default'](this, "credits", void 0);

    _defineProperty__default['default'](this, "lastEpochCredits", void 0);

    _defineProperty__default['default'](this, "epochCredits", void 0);
  }

  /**
   * Deserialize VoteAccount from the account data.
   *
   * @param buffer account data
   * @return VoteAccount
   */
  static fromAccountData(buffer) {
    const va = VoteAccountLayout.decode(toBuffer(buffer), 0);
    va.nodePubkey = new PublicKey(va.nodePubkey);
    va.authorizedVoterPubkey = new PublicKey(va.authorizedVoterPubkey);
    va.authorizedWithdrawerPubkey = new PublicKey(va.authorizedWithdrawerPubkey);

    if (!va.rootSlotValid) {
      va.rootSlot = null;
    }

    return va;
  }

}

//      
/**
 * Send and confirm a raw transaction
 *
 * If `commitment` option is not specified, defaults to 'max' commitment.
 *
 * @param {Connection} connection
 * @param {Buffer} rawTransaction
 * @param {ConfirmOptions} [options]
 * @returns {Promise<TransactionSignature>}
 */

async function sendAndConfirmRawTransaction(connection, rawTransaction, options) {
  const sendOptions = options && {
    skipPreflight: options.skipPreflight,
    preflightCommitment: options.preflightCommitment || options.commitment
  };
  const signature = await connection.sendRawTransaction(rawTransaction, sendOptions);
  const status = (await connection.confirmTransaction(signature, options && options.commitment)).value;

  if (status.err) {
    throw new Error(`Raw transaction ${signature} failed (${JSON.stringify(status)})`);
  }

  return signature;
}

//     

/**
 * @private
 */
const endpoint = {
  http: {
    devnet: 'http://devnet.solana.com',
    testnet: 'http://testnet.solana.com',
    'mainnet-beta': 'http://api.mainnet-beta.solana.com'
  },
  https: {
    devnet: 'https://devnet.solana.com',
    testnet: 'https://testnet.solana.com',
    'mainnet-beta': 'https://api.mainnet-beta.solana.com'
  }
};
/**
 * Retrieves the RPC API URL for the specified cluster
 */

function clusterApiUrl(cluster, tls) {
  const key = tls === false ? 'http' : 'https';

  if (!cluster) {
    return endpoint[key]['devnet'];
  }

  const url = endpoint[key][cluster];

  if (!url) {
    throw new Error(`Unknown ${key} cluster: ${cluster}`);
  }

  return url;
}

//      
/**
 * There are 1-billion lamports in one SOL
 */

const LAMPORTS_PER_SOL = 1000000000;

exports.Account = Account;
exports.Authorized = Authorized;
exports.BPF_LOADER_DEPRECATED_PROGRAM_ID = BPF_LOADER_DEPRECATED_PROGRAM_ID;
exports.BPF_LOADER_PROGRAM_ID = BPF_LOADER_PROGRAM_ID;
exports.BpfLoader = BpfLoader;
exports.Connection = Connection;
exports.LAMPORTS_PER_SOL = LAMPORTS_PER_SOL;
exports.Loader = Loader;
exports.Lockup = Lockup;
exports.MAX_SEED_LENGTH = MAX_SEED_LENGTH;
exports.Message = Message;
exports.NONCE_ACCOUNT_LENGTH = NONCE_ACCOUNT_LENGTH;
exports.NonceAccount = NonceAccount;
exports.PublicKey = PublicKey;
exports.STAKE_CONFIG_ID = STAKE_CONFIG_ID;
exports.STAKE_INSTRUCTION_LAYOUTS = STAKE_INSTRUCTION_LAYOUTS;
exports.SYSTEM_INSTRUCTION_LAYOUTS = SYSTEM_INSTRUCTION_LAYOUTS;
exports.SYSVAR_CLOCK_PUBKEY = SYSVAR_CLOCK_PUBKEY;
exports.SYSVAR_INSTRUCTIONS_PUBKEY = SYSVAR_INSTRUCTIONS_PUBKEY;
exports.SYSVAR_RENT_PUBKEY = SYSVAR_RENT_PUBKEY;
exports.SYSVAR_REWARDS_PUBKEY = SYSVAR_REWARDS_PUBKEY;
exports.SYSVAR_STAKE_HISTORY_PUBKEY = SYSVAR_STAKE_HISTORY_PUBKEY;
exports.Secp256k1Program = Secp256k1Program;
exports.StakeAuthorizationLayout = StakeAuthorizationLayout;
exports.StakeInstruction = StakeInstruction;
exports.StakeProgram = StakeProgram;
exports.SystemInstruction = SystemInstruction;
exports.SystemProgram = SystemProgram;
exports.Transaction = Transaction;
exports.TransactionInstruction = TransactionInstruction;
exports.VALIDATOR_INFO_KEY = VALIDATOR_INFO_KEY;
exports.VOTE_PROGRAM_ID = VOTE_PROGRAM_ID;
exports.ValidatorInfo = ValidatorInfo;
exports.VoteAccount = VoteAccount;
exports.clusterApiUrl = clusterApiUrl;
exports.sendAndConfirmRawTransaction = sendAndConfirmRawTransaction;
exports.sendAndConfirmTransaction = sendAndConfirmTransaction;
//# sourceMappingURL=index.cjs.js.map
